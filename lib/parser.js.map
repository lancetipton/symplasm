{"version":3,"sources":["parser.js"],"names":["parser","hasTerminalParent","parse","tokens","options","root","tagName","children","state","cursor","stack","terminals","tagParents","currentIndex","length","parentTagName","nodes","len","token","type","push","tagToken","content","toLowerCase","close","index","didRewind","splice","endToken","isClosingTag","closingTags","shouldRewindToAutoClose","closingTagAncestorBreakers","slice","previousIndex","attributes","attrToken","Array","isArray","reduce","attrs","attr","parts","hasChildren","voidTags","innerState"],"mappings":"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","file":"parser.js","sourcesContent":["import {arrayIncludes} from './compat'\n\nimport {\n  splitKeyValue,\n  unquote,\n} from './helpers'\n\nexport default function parser (tokens, options) {\n  const root = {tagName: null, children: []}\n  const state = {tokens, options, cursor: 0, stack: [root]}\n  parse(state)\n  return root.children\n}\n\nexport function hasTerminalParent (tagName, stack, terminals) {\n  const tagParents = terminals[tagName]\n  if (tagParents) {\n    let currentIndex = stack.length - 1\n    while (currentIndex >= 0) {\n      const parentTagName = stack[currentIndex].tagName\n      if (parentTagName === tagName) {\n        break\n      }\n      if (arrayIncludes(tagParents, parentTagName)) {\n        return true\n      }\n      currentIndex--\n    }\n  }\n  return false\n}\n\nexport function parse (state) {\n  const {tokens, options} = state\n  let {stack} = state\n  let nodes = stack[stack.length - 1].children\n  const len = tokens.length\n  let {cursor} = state\n  while (cursor < len) {\n    const token = tokens[cursor]\n    if (token.type !== 'tag-start') {\n      nodes.push(token)\n      cursor++\n      continue\n    }\n\n    const tagToken = tokens[++cursor]\n    cursor++\n    const tagName = tagToken.content.toLowerCase()\n    if (token.close) {\n      let index = stack.length\n      let didRewind = false\n      while (--index > -1) {\n        if (stack[index].tagName === tagName) {\n          stack.splice(index)\n          didRewind = true\n          break\n        }\n      }\n      while (cursor < len) {\n        const endToken = tokens[cursor]\n        if (endToken.type !== 'tag-end') break\n        cursor++\n      }\n      if (didRewind) {\n        break\n      } else {\n        continue\n      }\n    }\n\n    const isClosingTag = arrayIncludes(options.closingTags, tagName)\n    let shouldRewindToAutoClose = isClosingTag\n    if (shouldRewindToAutoClose) {\n      const { closingTagAncestorBreakers: terminals } = options\n      shouldRewindToAutoClose = !hasTerminalParent(tagName, stack, terminals)\n    }\n\n    if (shouldRewindToAutoClose) {\n      // rewind the stack to just above the previous\n      // closing tag of the same name\n      let currentIndex = stack.length - 1\n      while (currentIndex > 0) {\n        if (tagName === stack[currentIndex].tagName) {\n          stack = stack.slice(0, currentIndex)\n          const previousIndex = currentIndex - 1\n          nodes = stack[previousIndex].children\n          break\n        }\n        currentIndex = currentIndex - 1\n      }\n    }\n\n    let attributes = []\n    let attrToken\n    while (cursor < len) {\n      attrToken = tokens[cursor]\n      if (attrToken.type === 'tag-end') break\n      attributes.push(attrToken.content)\n      cursor++\n    }\n\n    cursor++\n    const children = []\n\n    attributes = Array.isArray(attributes) && attributes.length\n      ? attributes.reduce((attrs, attr) => {\n          const parts = splitKeyValue(attr, '=') \n          attrs[parts[0]] = parts[1] && unquote(parts[1]) || ''\n          return attrs\n        }, {})\n      : {}\n\n    nodes.push({\n      0: tagToken.content,\n      1: attributes,\n      2: children\n    })\n\n    const hasChildren = !(attrToken.close || arrayIncludes(options.voidTags, tagName))\n    if (hasChildren) {\n      stack.push({tagName, children})\n      const innerState = {tokens, options, cursor, stack}\n      parse(innerState)\n      cursor = innerState.cursor\n    }\n  }\n  state.cursor = cursor\n}"]}