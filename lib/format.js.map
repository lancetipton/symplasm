{"version":3,"sources":["format.js"],"names":["formatFS","options","root","className","active","trim","lowerCaseTag","nodes","_options","Object","assign","rootFS","format","formatAttributes","attributes","block","attrs","map","parts","splitHead","attribute","key","value","formatValue","parent","reduce","children","node","child","type","filterFS","push","indexOf","convertAttrs","JSON","parse","unquote","e","start","end","text","content","replace","length","tagName","toLowerCase","childComponents","str","sep","idx","slice","car","charAt","isQuoteStart"],"mappings":"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","file":"format.js","sourcesContent":["let options = {\n  root: {\n    0: 'div',\n    1: {\n      className: 'root-node',\n      active: true\n    }\n  },\n  trim: false,\n  lowerCaseTag: true\n}\n\nexport function formatFS (nodes, _options) {\n  Object.assign(options, _options)\n  const rootFS = Object.assign({}, options.root)\n  rootFS[2] = format(nodes, rootFS)\n  return rootFS\n}\n\nfunction formatAttributes (attributes, block) {\n  const attrs = {}\n  \n  attributes && attributes.map(attribute => {\n    const parts = splitHead(attribute.trim(), '=')\n    const key = parts[0]\n    const value = typeof parts[1] === 'string'\n      ? formatValue(parts[0], parts[1])\n      : null\n    attrs[key] = value\n  })\n  block[1] = attrs\n  return block\n}\n\nfunction format (nodes, parent) {\n  return nodes\n    ? nodes.reduce((children, node) => {\n        const child = node.type === 'text' || node.type === 'comment'\n          ? filterFS(node, parent)\n          : map(node)\n        child && children.push(child)\n        return children\n      }, [])\n    : []\n}\n\nfunction formatValue (key, value) {\n  if (key.indexOf('_') === 0 && options.convertAttrs) {\n    try { return JSON.parse(unquote(value)) } catch (e) {}\n  }\n  return unquote(value)\n}\n\nfunction filterFS (node, parent) {\n  let start = ''\n  let end = ''\n  let text = node.content\n  if (node.type === 'comment') {\n    start = '<!--'\n    end = '-->'\n  }\n  if (options.trim) {\n    return node.content.trim() !== '\\n' && node.content.replace(/\\s/g, '').length > 0\n      ? start + node.content.trim() + end\n      : null\n  }\n  return text\n    ? start + text + end\n    : null\n}\n\nfunction map (node) {\n  let block = {}\n  block[0] = options.lowerCaseTag\n    ? node.tagName.toLowerCase()\n    : node.tagName\n  \n  block = formatAttributes(node.attributes, block)\n  \n  let childComponents = format(node.children, block)\n  if (childComponents.length > 0) {\n    block[2] = childComponents\n  }\n  return block\n}\n\nfunction splitHead (str, sep) {\n  const idx = str.indexOf(sep)\n  if (idx === -1) return [str]\n  return [str.slice(0, idx), str.slice(idx + sep.length)]\n}\n\nfunction unquote (str) {\n  const car = str.charAt(0)\n  const end = str.length - 1\n  const isQuoteStart = car === '\"' || car === \"'\"\n  if (isQuoteStart && car === str.charAt(end)) {\n    return str.slice(1, end)\n  }\n  return str\n}"]}