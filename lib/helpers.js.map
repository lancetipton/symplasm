{"version":3,"sources":["helpers.js"],"names":["selectTypes","addChildren","block","childs","addChilds","length","Array","isArray","concat","convertCase","converted","text_split","text","split","shift","map","val","charAt","toUpperCase","slice","convertStyle","valObj","val_split","styles","trim","item","indexOf","item_split","setupSelectors","selectorCheck","options","selectorArr","Object","keys","key","attribute","attr","elementSelectors","selector","isArr","value","tags","select","allTags","props","el","hasSelectors","tag","type","replace","console","warn","push","assign","all","splitKeyValue","str","sep","idx","unquote","car","end","isQuoteStart"],"mappings":"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","file":"helpers.js","sourcesContent":["const selectTypes = [[ 'class', '.'], [ 'id', '#'], [ 'data', '[']]\n\nconst addChildren = (block, childs) => {\n  const addChilds = childs.length === 1 && typeof childs[0] === 'string'\n    ? childs[0]\n    : childs.length && childs || null\n\n  if(addChilds) {\n    if(!block[2]) block[2] = addChilds\n    else if(Array.isArray(block[2])) block[2] = block[2].concat(addChilds)\n    else block[2] = [block[2]].concat(addChilds)\n  }\n  return block\n}\n\nconst convertCase = text => {\n  let converted = ''\n  const text_split = text.split('-')\n  if(!text_split.length) return text\n  converted += text_split.shift()\n  text_split.map(val => {\n    converted += val.charAt(0).toUpperCase() + val.slice(1)\n  })\n  return converted\n}\n\nconst convertStyle = styles => {\n  const valObj = {}\n  const val_split = styles.trim().split(';')\n  \n  Array.isArray(val_split) &&\n    val_split[0].trim() !== '' &&\n    val_split.map(item => {\n      if (item.indexOf(':') !== -1) {\n        const item_split = item.split(':')\n        if (Array.isArray(item_split) && item_split.length === 2) {\n          if (item_split[0].trim() !== '' && item_split[1].trim() !== '') {\n            valObj[convertCase(item_split[0].trim())] = item_split[1].trim()\n          }\n        }\n      }\n    })\n\n  return valObj\n}\n\n\nconst setupSelectors = (selectorCheck, options) => {\n  const selectorArr = Object.keys(selectorCheck)\n  Object.keys(options).map(key => {\n    // Only check keys from the selector Array\n    if(selectorArr.indexOf(key) === -1) return\n    \n    Object.keys(options[key]).map(attr => {\n      // Get the attribute to be checked - i.e. class / id / name\n      const attribute = options[key][attr]\n      \n      // Get the element selectors,\n      let elementSelectors = attribute.selector\n      \n      if(key !== 'tagConvert'){\n        // If it's just a string set it, and return\n        // This means all items should be coverted\n        // i.e. class='className'\n        if(typeof attribute === 'string' || typeof attribute === 'function'){\n          selectorCheck[key][attr] = attribute\n          return\n        }\n\n        // If there's no selectors, loop the attribute and add the keys \n        // to the elementSelector\n        if(!elementSelectors && Object.keys(attribute).length){\n          elementSelectors = {}\n          Object.keys(attribute).map(key => {\n            elementSelectors[key] = attribute[key]\n          })\n        }\n\n        if(!elementSelectors) return\n        // Set the default for the selectorCheck items\n        selectorCheck[key][attr] = selectorCheck[key][attr] || {}\n      }\n      else {\n        elementSelectors = {}\n        elementSelectors[attr] = attribute\n      }\n\n      // chache selector type\n      const isArr = Array.isArray(elementSelectors)\n      // check that is has a value to return\n      if(isArr){\n        // If it's an array and there is no value, we have no way to conver the items\n        // So just return\n        if(!options[key][attr].value) return\n        // Otherwise set the items\n        selectorCheck[key][attr].value = options[key][attr].value\n      }\n      \n      Object.keys(elementSelectors).map(select => {\n        // Selector tags - i.e. input.class / button#primary / select[td-select]\n        const tags = isArr && elementSelectors[select] || select\n        // split all tags if more then 1\n        const allTags = tags.split(',')\n        // loop tags and split on selector type - i.e. class / id / name\n        allTags.map(tag => {\n          const props = {}\n          let el\n          const hasSelectors = []\n          // Loop selector types and add to select checker\n          // This checks for a class / id / attribute on the select item\n          selectTypes.map(type => {\n            // If it has the passed in type in the string convert it, and add the the props\n            if(tag.indexOf(type[1]) !== -1){\n              const split = tag.split(type[1])\n              props[type[0]] = split[1].replace(']', '')\n              el = split[0]\n              if(el.indexOf('.') !== -1 || el.indexOf('#') !== -1 || el.indexOf('[') !== -1 ){\n                console.warn(`Error: \"${el}\" is not formatted correctly. It contains one of \". # [\"`)\n              }\n              // Update that we have a select type on the selector\n              hasSelectors.push(true)\n            }\n          })\n          // Check if a select type was found on the selector\n          // This will be an array of true if it had a select type on it\n          // If no class / id / attribute was found on the selector, it will be an empty array\n          if(hasSelectors.indexOf(true) !== -1){\n            if(key !== 'tagConvert'){\n              // Add the tags and props to make converstion\n              selectorCheck[key][attr][el] = props\n              // If it's not an array, add the value to the elment props object\n              if(!isArr) selectorCheck[key][attr][el].value = elementSelectors[select]\n              return\n            }\n            selectorCheck[key] = selectorCheck[key] || {}\n            selectorCheck[key][el] = selectorCheck[key][el] || {}\n            selectorCheck[key][el][el] = Object.assign({}, props)\n            selectorCheck[key][el][el].value = elementSelectors[select]\n          }\n          else {\n            if(key !== 'tagConvert'){\n\n              // Add the tags and props to make converstion\n              // Setting all true because the selector did not have an class / id / or attr tied to it\n              selectorCheck[key][attr][tag] = { all: true }\n              // If it's not an array, add the value to the elment props object\n              if(!isArr) selectorCheck[key][attr][tag].value = elementSelectors[select]\n              return\n            }\n            selectorCheck[key] = selectorCheck[key] || {}\n            selectorCheck[key][tag] = selectorCheck[key][tag] || {}\n            selectorCheck[key][tag][tag] = {\n              all: true,\n              value: elementSelectors[select]\n            }\n          }\n        })\n      })\n\n    })\n  })\n  \n  return selectorCheck\n}\n\nconst splitKeyValue = (str, sep) => {\n  const idx = str.indexOf(sep)\n  if (idx === -1) return [str]\n  return [str.slice(0, idx), str.slice(idx + sep.length)]\n}\n\nconst unquote = str => {\n  const car = str.charAt(0)\n  const end = str.length - 1\n  const isQuoteStart = car === '\"' || car === \"'\"\n  if (isQuoteStart && car === str.charAt(end)) {\n    return str.slice(1, end)\n  }\n  return str\n}\n\nexport {\n  addChildren,\n  convertCase,\n  convertStyle,\n  setupSelectors,\n  splitKeyValue,\n  unquote\n}"]}