{"version":3,"sources":["helpers.js"],"names":["selectTypes","addChildren","block","childs","addChilds","length","Array","isArray","concat","convertCase","converted","text_split","text","split","shift","map","val","charAt","toUpperCase","slice","convertStyle","valObj","val_split","styles","trim","item","indexOf","item_split","setupSelectors","selectorCheck","options","selectorArr","Object","keys","key","props","attribute","attr","elementSelectors","selector","isArr","value","tags","select","allTags","tag","clean","_tag","el","hasSelectors","type","dataSplit","replace","dataKey","assign","console","warn","push","loc","all","splitKeyValue","str","sep","idx","unquote","car","end","isQuoteStart"],"mappings":"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","file":"helpers.js","sourcesContent":["const selectTypes = [[ 'class', '.'], [ 'id', '#'], [ 'data', '[']]\n\nconst addChildren = (block, childs) => {\n  const addChilds = childs.length === 1 && typeof childs[0] === 'string'\n    ? childs[0]\n    : childs.length && childs || null\n\n  if(addChilds) {\n    if(!block[2]) block[2] = addChilds\n    else if(Array.isArray(block[2])) block[2] = block[2].concat(addChilds)\n    else block[2] = [block[2]].concat(addChilds)\n  }\n  return block\n}\n\nconst convertCase = text => {\n  let converted = ''\n  const text_split = text.split('-')\n  if(!text_split.length) return text\n  converted += text_split.shift()\n  text_split.map(val => {\n    converted += val.charAt(0).toUpperCase() + val.slice(1)\n  })\n  return converted\n}\n\nconst convertStyle = styles => {\n  const valObj = {}\n  const val_split = styles.trim().split(';')\n  \n  Array.isArray(val_split) &&\n    val_split[0].trim() !== '' &&\n    val_split.map(item => {\n      if (item.indexOf(':') !== -1) {\n        const item_split = item.split(':')\n        if (Array.isArray(item_split) && item_split.length === 2) {\n          if (item_split[0].trim() !== '' && item_split[1].trim() !== '') {\n            valObj[convertCase(item_split[0].trim())] = item_split[1].trim()\n          }\n        }\n      }\n    })\n\n  return valObj\n}\n\n\nconst setupSelectors = (selectorCheck, options) => {\n  const selectorArr = Object.keys(selectorCheck)\n  Object.keys(options).map(key => {\n    // Only check keys from the selector Array\n    if(selectorArr.indexOf(key) === -1) return\n    \n    const props = {}\n    Object.keys(options[key]).map(attr => {\n      // Get the attribute to be checked - i.e. class / id / name\n      const attribute = options[key][attr]\n\n      // Get the element selectors,\n      let elementSelectors = attribute && attribute.selector\n      \n      if(key !== 'tagConvert'){\n        // If it's just a string set it, and return\n        // This means all items should be coverted\n        // i.e. class='className'\n        if(typeof attribute === 'string' || typeof attribute === 'function'){\n          selectorCheck[key][attr] = attribute\n          return\n        }\n\n        // If there's no selectors, loop the attribute and add the keys \n        // to the elementSelector\n        if(attribute && !elementSelectors && Object.keys(attribute).length){\n          elementSelectors = {}\n          Object.keys(attribute).map(key => {\n            elementSelectors[key] = attribute[key]\n          })\n        }\n\n        if(!elementSelectors){\n          if(attribute === null) selectorCheck[key][attr] = null\n          return\n        }\n        // Set the default for the selectorCheck items\n        selectorCheck[key][attr] = selectorCheck[key][attr] || {}\n      }\n      else {\n        elementSelectors = {}\n        elementSelectors[attr] = attribute\n      }\n\n      // chache selector type\n      const isArr = Array.isArray(elementSelectors)\n      // check that is has a value to return\n      if(isArr){\n        // If it's an array and there is no value, we have no way to conver the items\n        // So just return\n        if(!options[key][attr].value) return\n        // Otherwise set the items\n        selectorCheck[key][attr].value = options[key][attr].value\n      }\n\n      Object.keys(elementSelectors).map(select => {\n        // Selector tags - i.e. input.class / button#primary / select[td-select]\n        const tags = isArr && elementSelectors[select] || select\n        // split all tags if more then 1\n        const allTags = tags.split(',')\n        // loop tags and split on selector type - i.e. class / id / name\n        allTags.map(_tag => {\n          const tag = clean(_tag)\n          let el\n          \n          const hasSelectors = []\n          // Loop selector types and add to select checker\n          // This checks for a class / id / attribute on the select item\n          selectTypes.map(type => {\n            // If it has the passed in type in the string convert it, and add the the props\n            if(tag.indexOf(type[1]) !== -1){\n              const split = tag.split(type[1])\n              if(type[0] === 'data'){\n                const dataSplit = split[1].split('=')\n                const key = clean(dataSplit[0].replace(']', ''))\n                const dataKey = dataSplit[1] && clean(dataSplit[1].replace(']', '')) || ''\n                props[key] = Object.assign({}, props[key], {\n                  [dataKey]: elementSelectors[select]\n                })\n              }\n              else {\n                props[type[0]] = Object.assign({}, props[type[0]], {\n                  [clean(split[1])]: elementSelectors[select]\n                })\n              }\n\n              el = clean(split[0])\n              if(el.indexOf('.') !== -1 || el.indexOf('#') !== -1 || el.indexOf('[') !== -1 ){\n                console.warn(`Error: \"${el}\" is not formatted correctly. It contains one of \". # [\"`)\n              }\n              // Update that we have a select type on the selector\n              hasSelectors.push(true)\n            }\n          })\n\n          // Check if a select type was found on the selector\n          // This will be an array of true if it had a select type on it\n          // If no class / id / attribute was found on the selector, it will be an empty array\n          // ------------------ ELEMENT WITH A SELECTOR ------------------ //\n          if(hasSelectors.indexOf(true) !== -1){\n            const loc = key !== 'tagConvert'\n              ? attr\n              : el\n            selectorCheck[key] = selectorCheck[key] || {}\n            selectorCheck[key][loc] = selectorCheck[key][loc] || {}\n            selectorCheck[key][loc][el] = Object.assign({}, selectorCheck[key][loc][el], props)\n          }\n          // ------------------ ALL OF ELEMENT TYPE ------------------ //\n          else {\n            const loc = key !== 'tagConvert'\n              ? attr\n              : tag\n              \n            selectorCheck[key] = selectorCheck[key] || {}\n            selectorCheck[key][loc] = selectorCheck[key][loc] || {}\n            selectorCheck[key][loc][tag] = selectorCheck[key][loc][tag] || {}\n            selectorCheck[key][loc][tag].all = elementSelectors[select]\n          }\n        })\n      })\n    })\n  })\n\n  return selectorCheck\n}\n\nconst splitKeyValue = (str, sep) => {\n  const idx = str.indexOf(sep)\n  if (idx === -1) return [str]\n  return [str.slice(0, idx), str.slice(idx + sep.length)]\n}\n\nconst clean = (str) => {\n  return str && unquote(str.trim()).trim() || ''\n}\n\nconst unquote = str => {\n  const car = str.charAt(0)\n  const end = str.length - 1\n  const isQuoteStart = car === '\"' || car === \"'\"\n  if (isQuoteStart && car === str.charAt(end)) {\n    return str.slice(1, end)\n  }\n  return str\n}\n\nexport {\n  addChildren,\n  convertCase,\n  convertStyle,\n  setupSelectors,\n  splitKeyValue,\n  unquote\n}"]}