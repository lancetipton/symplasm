{"version":3,"names":[],"mappings":"","sources":["symplasm.js"],"sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.symplasm = f()}})(function(){var define,module,exports;return (function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.startsWith = startsWith;\nexports.endsWith = endsWith;\nexports.stringIncludes = stringIncludes;\nexports.isRealNaN = isRealNaN;\nexports.arrayIncludes = arrayIncludes;\n/*\n  We don't want to include babel-polyfill in our project.\n    - Library authors should be using babel-runtime for non-global polyfilling\n    - Adding babel-polyfill/-runtime increases bundle size significantly\n\n  We will include our polyfill instance methods as regular functions.\n*/\n\nfunction startsWith(str, searchString, position) {\n  return str.substr(position || 0, searchString.length) === searchString;\n}\n\nfunction endsWith(str, searchString, position) {\n  var index = (position || str.length) - searchString.length;\n  var lastIndex = str.lastIndexOf(searchString, index);\n  return lastIndex !== -1 && lastIndex === index;\n}\n\nfunction stringIncludes(str, searchString, position) {\n  return str.indexOf(searchString, position || 0) !== -1;\n}\n\nfunction isRealNaN(x) {\n  return typeof x === 'number' && isNaN(x);\n}\n\nfunction arrayIncludes(array, searchElement, position) {\n  var len = array.length;\n  if (len === 0) return false;\n\n  var lookupIndex = position | 0;\n  var isNaNElement = isRealNaN(searchElement);\n  var searchIndex = lookupIndex >= 0 ? lookupIndex : len + lookupIndex;\n  while (searchIndex < len) {\n    var element = array[searchIndex++];\n    if (element === searchElement) return true;\n    if (isNaNElement && isRealNaN(element)) return true;\n  }\n\n  return false;\n}\n\n},{}],2:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar options = {\n  root: {\n    0: 'div',\n    1: {\n      class: 'root-node'\n    }\n  },\n  tagConvert: {},\n  attrKeyConvert: {},\n  attrValueConvert: {},\n  attrKeyAdd: {},\n  trim: false,\n  lowerCaseTag: true\n};\n\nvar selectorCheck = {\n  tagConvert: {},\n  attrKeyConvert: {},\n  attrValueConvert: {},\n  attrKeyAdd: {}\n};\nvar attrArrEmpty = true;\n\n// ----------- Converters ----------- //\nvar convertCase = function convertCase(text) {\n  var converted = '';\n  var text_split = text.split('-');\n  if (!text_split.length) return text;\n  converted += text_split.shift();\n  text_split.map(function (val) {\n    converted += val.charAt(0).toUpperCase() + val.slice(1);\n  });\n  return converted;\n};\n\nvar convertStyle = function convertStyle(styles) {\n  var valObj = {};\n  var val_split = styles.trim().split(';');\n\n  Array.isArray(val_split) && val_split[0].trim() !== '' && val_split.map(function (item) {\n    if (item.indexOf(':') !== -1) {\n      var item_split = item.split(':');\n      if (Array.isArray(item_split) && item_split.length === 2) {\n        if (item_split[0].trim() !== '' && item_split[1].trim() !== '') {\n          valObj[convertCase(item_split[0].trim())] = item_split[1].trim();\n        }\n      }\n    }\n  });\n\n  return valObj;\n};\n\nvar convertBlock = function convertBlock(block, nodes, children) {\n  block[0] = options.tagConvert[block[0]] ? runAction({\n    action: options.tagConvert[block[0]],\n    node: block,\n    key: '$$DOM_TAG_NAME',\n    value: block[0],\n    nodes: nodes,\n    children: children\n  }, 'value') : block[0];\n\n  block[1] = _typeof(block[1]) === 'object' ? Object.keys(block[1]).reduce(function (attrs, key) {\n    var useKey = options.attrKeyConvert[key] ? runAction({\n      action: options.attrKeyConvert[key],\n      node: block,\n      value: block[1][key],\n      key: key,\n      nodes: nodes,\n      children: children\n    }, 'key') : key;\n\n    if (useKey && block[1][key]) {\n      attrs[useKey] = options.attrValueConvert[key] ? runAction({\n        action: options.attrValueConvert[key],\n        node: block,\n        value: block[1][key],\n        key: key,\n        nodes: nodes,\n        children: children\n      }, 'value') : unquote(block[1][key]);\n    }\n\n    return attrs;\n  }, {}) : {};\n\n  if (block[2] && typeof block[2] !== 'string' && block[2].length) {\n    block[2] = block[2].map(function (child) {\n      return convertBlock(child, nodes, children);\n    });\n  }\n\n  return block;\n};\n\nvar buildBlock = function buildBlock(org, added, nodes, children) {\n  org[0] = added[0];\n  org[1] = Object.assign({}, org[1], added[1]);\n  if (added[2]) org[2] = added[2];\n  return convertBlock(org, nodes, children);\n};\n\nvar tagConvert = function tagConvert(args) {\n  var action = args.action,\n      node = args.node,\n      value = args.value,\n      nodes = args.nodes,\n      children = args.children;\n  var block = args.block;\n\n\n  var tagName = node.tagName || node[0];\n  if (!tagName) return block;\n  block[0] = options.lowerCaseTag ? tagName.toLowerCase() : tagName;\n\n  if (typeof action === 'function') {\n    var data = runAction({\n      key: '$$DOM_TAG_NAME',\n      value: block[0],\n      action: action,\n      node: node,\n      nodes: nodes,\n      children: children\n    }, 'value');\n    if (!data) return block;\n    if (typeof data === 'string') data = { 0: data };\n\n    if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') return buildBlock(block, data, nodes, children);\n  } else if ((typeof action === 'undefined' ? 'undefined' : _typeof(action)) === 'object' && !Array.isArray(action) && action[0]) {\n    return buildBlock(block, action, nodes, children);\n  } else block[0] = runAction({\n    key: '$$DOM_TAG_NAME',\n    value: block[0],\n    action: action,\n    node: node,\n    nodes: nodes,\n    children: children\n  }, 'value');\n\n  return block;\n};\n\n// ----------- Run options methods ----------- //\nvar runAction = function runAction(args, def) {\n  var action = args.action,\n      node = args.node,\n      key = args.key,\n      value = args.value,\n      nodes = args.nodes,\n      children = args.children;\n\n\n  switch (typeof action === 'undefined' ? 'undefined' : _typeof(action)) {\n    case 'function':\n      return action(node, key, value, nodes, children, options) || action;\n    case 'object':\n      var tagType = node.tagName || node[0];\n      var updateValue = !action.selector;\n      // Run default actions if no selector specified\n      if (_typeof(action.selector) === 'object') {\n        if (Array.isArray(action.selector) && action.selector.indexOf(tagType) !== -1) {}\n\n        Object.keys(action.selector).map(function (key) {\n          var actionValue = action.selector[key];\n          if (typeof actionValue === 'string') {}\n          if ((typeof actionValue === 'undefined' ? 'undefined' : _typeof(actionValue)) === 'object') {}\n        });\n      }\n      if (updateValue) {\n        if (!tagType || !action.value) return value;\n        if (typeof action.value === 'string') return action.value;\n        if (typeof action.value === 'function') return action.value(node, key, value, nodes, children, options);\n      }\n\n      return args[def];\n    default:\n      return action;\n  }\n};\n\n// ----------- Formatters ----------- //\nvar format = function format(args) {\n  var parent = args.parent,\n      children = args.children;\n  var childs = args.childs,\n      nodes = args.nodes;\n\n\n  return childs ? childs.reduce(function (children, node) {\n    nodes = nodes || childs;\n    var child = node.type === 'text' || node.type === 'comment' ? filterFS(node, parent) : formatNode(node, childs, nodes, children);\n    child && children.push(child);\n    return children;\n  }, []) : [];\n};\n\nvar formatNode = function formatNode(node, nodes, children) {\n\n  var block = options.tagConvert[node.tagName] ? tagConvert({\n    action: options.tagConvert[node.tagName],\n    block: {},\n    value: node.tagName,\n    node: node,\n    nodes: nodes,\n    children: children\n  }) : { 0: node.tagName };\n\n  var attrs = formatAttributes({\n    attributes: node.attributes,\n    node: node,\n    nodes: nodes,\n    children: children\n  });\n  block[1] = Object.assign({}, block[1], attrs);\n\n  var childs = format({\n    childs: node.children,\n    parent: block,\n    nodes: nodes,\n    children: children\n  });\n  return addChildren(block, childs);\n};\n\nvar formatAttributes = function formatAttributes(args) {\n  var node = args.node,\n      attributes = args.attributes,\n      nodes = args.nodes,\n      children = args.children;\n\n  var attrs = {};\n\n  var isArray = Array.isArray(attributes);\n  Object.keys(attributes).map(function (item) {\n    var parts = isArray ? splitKeyValue(attributes[item].trim(), '=') : [item, attributes[item]];\n\n    var key = options.attrKeyConvert && options.attrKeyConvert[parts[0]] ? runAction({\n      action: options.attrKeyConvert[parts[0]],\n      key: parts[0],\n      value: parts[1],\n      node: node,\n      nodes: nodes,\n      children: children\n    }, 'key') : parts[0];\n\n    var value = typeof parts[1] === 'string' ? formatValue({\n      key: parts[0],\n      value: parts[1],\n      node: node,\n      nodes: nodes,\n      children: children\n    }) : null;\n    if (key && value) attrs[key] = value;\n  });\n\n  if (attrArrEmpty) return attrs;\n\n  return addAttribute({\n    node: node,\n    attrs: attrs,\n    nodes: nodes,\n    children: children\n  });\n};\n\nvar formatValue = function formatValue(args) {\n  var node = args.node,\n      key = args.key,\n      value = args.value,\n      nodes = args.nodes,\n      children = args.children;\n\n  return key === 'style' && typeof value === 'string' ? convertStyle(unquote(value)) : options.attrValueConvert[key] ? runAction({\n    action: options.attrValueConvert[key],\n    value: unquote(value),\n    node: node,\n    key: key,\n    nodes: nodes,\n    children: children\n  }, 'value') : unquote(value);\n};\n\n// ----------- Helpers ----------- //\nvar getSelector = function getSelector(node, selector) {};\n\nvar checkSelector = function checkSelector(args) {\n  var action = args.action,\n      node = args.node,\n      key = args.key,\n      value = args.value,\n      nodes = args.nodes,\n      children = args.children;\n\n  var tagType = node.tagName || node[0];\n\n  if (action.selector) {}\n  // runAction\n  // action, node, key, value, nodes, children\n  // action.selector && action.selector.indexOf(tagType) === -1\n\n  // addAttribute\n  // node, attrs, nodes, children\n  // !action.selector || action.selector.indexOf(node.tagName) !== -1\n};\n\nvar addAttribute = function addAttribute(args) {\n  var node = args.node,\n      attrs = args.attrs,\n      nodes = args.nodes,\n      children = args.children;\n\n\n  Object.keys(options.attrKeyAdd).map(function (key) {\n    var action = options.attrKeyAdd[key];\n    var value = void 0;\n    if ((typeof action === 'undefined' ? 'undefined' : _typeof(action)) === 'object') {\n      if (!action.value) return;\n      var checkArgs = Object.assign({}, args, { action: action, key: key });\n\n      if (checkSelector(checkArgs)) {\n        value = typeof action.value === 'function' ? action.value(node, key, action.value, nodes, children, options) : action.value;\n      }\n    } else {\n      value = runAction({\n        action: options.attrKeyAdd[key],\n        value: action.value,\n        node: node,\n        key: key,\n        nodes: nodes,\n        children: children\n      });\n    }\n    if (value) attrs[key] = value;\n  });\n\n  return attrs;\n};\n\nvar addChildren = function addChildren(block, childs) {\n  var addChilds = childs.length === 1 && typeof childs[0] === 'string' ? childs[0] : childs.length && childs || null;\n\n  if (addChilds) {\n    if (!block[2]) block[2] = addChilds;else if (Array.isArray(block[2])) block[2] = block[2].concat(addChilds);else block[2] = [block[2]].concat(addChilds);\n  }\n  return block;\n};\n\nvar splitKeyValue = function splitKeyValue(str, sep) {\n  var idx = str.indexOf(sep);\n  if (idx === -1) return [str];\n  return [str.slice(0, idx), str.slice(idx + sep.length)];\n};\n\nvar unquote = function unquote(str) {\n  var car = str.charAt(0);\n  var end = str.length - 1;\n  var isQuoteStart = car === '\"' || car === \"'\";\n  if (isQuoteStart && car === str.charAt(end)) {\n    return str.slice(1, end);\n  }\n  return str;\n};\n\nvar filterFS = function filterFS(node) {\n  var start = '';\n  var end = '';\n  var text = node.content;\n  if (node.type === 'comment') {\n    start = '<!--';\n    end = '-->';\n  }\n  if (options.trim) {\n    return node.content.trim() !== '\\n' && node.content.replace(/\\s/g, '').length > 0 ? start + node.content.trim() + end : null;\n  }\n  return text ? start + text + end : null;\n};\n\nvar setupSelectors = function setupSelectors() {\n  var selectorArr = ['tagConvert', 'attrKeyConvert', 'attrValueConvert', 'attrKeyAdd'];\n  var selectTypes = [['class', '.'], ['id', '#'], ['data', '[']];\n\n  Object.keys(options).map(function (key) {\n    if (selectorArr.indexOf(key) === -1) return;\n\n    Object.keys(options[key]).map(function (attr) {\n      // Get the attribute to be checked - i.e. class / id / name\n      var attribute = options[key][attr];\n      // No selector, just return\n      if (!attribute.selector) return;\n      selectorCheck[key][attr] = selectorCheck[key][attr] || {};\n      // chache selector type\n      var isArr = Array.isArray(attribute.selector);\n      // check that is has a value to return\n      if (isArr) {\n        if (!options[key][attr].value) return;\n        selectorCheck[key][attr].value = options[key][attr].value;\n      } else if (!attribute.selector[select].value) return;\n\n      Object.keys(attribute.selector).map(function (select) {\n        // Selector tags - i.e. input.class / button#primary / select[td-select]\n        var tags = isArr && attribute.selector[select] || select;\n        // split all tags if more then 1\n        var allTags = tags.split(',');\n        // loop tags and split on selector type - i.e. class / id / name\n        allTags.map(function (tag) {\n          var props = {};\n          var el = void 0;\n          var hasSelectors = [];\n          // Loop selector types and add to select checker\n          selectTypes.map(function (type) {\n            if (tag.indexOf(type[1]) !== -1) {\n              var split = tag.split(type[1]);\n              props[type[0]] = split[1].replace(']', '');\n              el = split[0];\n              hasSelectors.push(true);\n            }\n          });\n          if (hasSelectors.indexOf(true) !== -1) {\n            selectorCheck[key][attr][el] = props;\n            if (!isArr) selectorCheck[key][attr][el].value = attribute.selector[select].value;\n          } else {\n            selectorCheck[key][attr][tag] = '*';\n            if (!isArr) selectorCheck[key][attr][tag].value = attribute.selector[select].value;\n          }\n        });\n      });\n    });\n  });\n};\n\nvar formatFS = exports.formatFS = function formatFS(nodes, _options) {\n  var rootFS = Object.assign({}, options.root, _options.root);\n  Object.assign(options, _options);\n  setupSelectors(options);\n\n  console.log(selectorCheck);\n\n  attrArrEmpty = Object.keys(options.attrKeyAdd).length === 0;\n  if (options.tagConvert[rootFS[0]]) {\n    rootFS = tagConvert({\n      action: options.tagConvert[rootFS[0]],\n      block: rootFS,\n      value: rootFS[0],\n      node: rootFS,\n      children: nodes,\n      nodes: nodes\n    });\n  }\n  rootFS[1] = formatAttributes({\n    attributes: rootFS[1],\n    node: rootFS,\n    children: nodes,\n    nodes: nodes\n  });\n  return addChildren(rootFS, format({\n    childs: nodes,\n    parent: rootFS\n  }));\n};\n\n},{}],3:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseDefaults = undefined;\nexports.parse = parse;\nexports.stringify = stringify;\n\nvar _lexer = require('./lexer');\n\nvar _lexer2 = _interopRequireDefault(_lexer);\n\nvar _parser = require('./parser');\n\nvar _parser2 = _interopRequireDefault(_parser);\n\nvar _stringify = require('./stringify');\n\nvar _format = require('./format');\n\nvar _tags = require('./tags');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar parseDefaults = exports.parseDefaults = {\n  voidTags: _tags.voidTags,\n  closingTags: _tags.closingTags,\n  childlessTags: _tags.childlessTags,\n  closingTagAncestorBreakers: _tags.closingTagAncestorBreakers,\n  includePositions: false\n};\n\nfunction parse(str) {\n  var options = Object.assign(parseDefaults, arguments[1]);\n  var tokens = (0, _lexer2.default)(str, options);\n  var nodes = (0, _parser2.default)(tokens, options);\n  return (0, _format.formatFS)(nodes, options);\n}\n\nfunction stringify(ast) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : parseDefaults;\n\n  return Array.isArray(ast) ? (0, _stringify.toHTML)(ast, options) : (0, _stringify.toHTML)([ast], options);\n}\n\n},{\"./format\":2,\"./lexer\":4,\"./parser\":5,\"./stringify\":6,\"./tags\":7}],4:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.feedPosition = feedPosition;\nexports.jumpPosition = jumpPosition;\nexports.makeInitialPosition = makeInitialPosition;\nexports.copyPosition = copyPosition;\nexports.default = lexer;\nexports.lex = lex;\nexports.findTextEnd = findTextEnd;\nexports.lexText = lexText;\nexports.lexComment = lexComment;\nexports.lexTag = lexTag;\nexports.isWhitespaceChar = isWhitespaceChar;\nexports.lexTagName = lexTagName;\nexports.lexTagAttributes = lexTagAttributes;\nexports.lexSkipTag = lexSkipTag;\n\nvar _compat = require('./compat');\n\nfunction feedPosition(position, str, len) {\n  var start = position.index;\n  var end = position.index = start + len;\n  for (var i = start; i < end; i++) {\n    var char = str.charAt(i);\n    if (char === '\\n') {\n      position.line++;\n      position.column = 0;\n    } else {\n      position.column++;\n    }\n  }\n}\n\nfunction jumpPosition(position, str, end) {\n  var len = end - position.index;\n  return feedPosition(position, str, len);\n}\n\nfunction makeInitialPosition() {\n  return {\n    index: 0,\n    column: 0,\n    line: 0\n  };\n}\n\nfunction copyPosition(position) {\n  return {\n    index: position.index,\n    line: position.line,\n    column: position.column\n  };\n}\n\nfunction lexer(str, options) {\n  var state = {\n    str: str,\n    options: options,\n    position: makeInitialPosition(),\n    tokens: []\n  };\n  lex(state);\n  return state.tokens;\n}\n\nfunction lex(state) {\n  var str = state.str,\n      childlessTags = state.options.childlessTags;\n\n  var len = str.length;\n  while (state.position.index < len) {\n    var start = state.position.index;\n    lexText(state);\n    if (state.position.index === start) {\n      var isComment = (0, _compat.startsWith)(str, '!--', start + 1);\n      if (isComment) {\n        lexComment(state);\n      } else {\n        var tagName = lexTag(state);\n        var safeTag = tagName.toLowerCase();\n        if ((0, _compat.arrayIncludes)(childlessTags, safeTag)) {\n          lexSkipTag(tagName, state);\n        }\n      }\n    }\n  }\n}\n\nvar alphanumeric = /[A-Za-z0-9]/;\nfunction findTextEnd(str, index) {\n  while (true) {\n    var textEnd = str.indexOf('<', index);\n    if (textEnd === -1) {\n      return textEnd;\n    }\n    var char = str.charAt(textEnd + 1);\n    if (char === '/' || char === '!' || alphanumeric.test(char)) {\n      return textEnd;\n    }\n    index = textEnd + 1;\n  }\n}\n\nfunction lexText(state) {\n  var type = 'text';\n  var str = state.str,\n      position = state.position;\n\n  var textEnd = findTextEnd(str, position.index);\n  if (textEnd === position.index) return;\n  if (textEnd === -1) {\n    textEnd = str.length;\n  }\n\n  var start = copyPosition(position);\n  var content = str.slice(position.index, textEnd);\n  jumpPosition(position, str, textEnd);\n  var end = copyPosition(position);\n  state.tokens.push({ type: type, content: content, position: { start: start, end: end } });\n}\n\nfunction lexComment(state) {\n  var str = state.str,\n      position = state.position;\n\n  var start = copyPosition(position);\n  feedPosition(position, str, 4); // \"<!--\".length\n  var contentEnd = str.indexOf('-->', position.index);\n  var commentEnd = contentEnd + 3; // \"-->\".length\n  if (contentEnd === -1) {\n    contentEnd = commentEnd = str.length;\n  }\n\n  var content = str.slice(position.index, contentEnd);\n  jumpPosition(position, str, commentEnd);\n  state.tokens.push({\n    type: 'comment',\n    content: content,\n    position: {\n      start: start,\n      end: copyPosition(position)\n    }\n  });\n}\n\nfunction lexTag(state) {\n  var str = state.str,\n      position = state.position;\n\n  {\n    var secondChar = str.charAt(position.index + 1);\n    var close = secondChar === '/';\n    var start = copyPosition(position);\n    feedPosition(position, str, close ? 2 : 1);\n    state.tokens.push({ type: 'tag-start', close: close, position: { start: start } });\n  }\n  var tagName = lexTagName(state);\n  lexTagAttributes(state);\n  {\n    var firstChar = str.charAt(position.index);\n    var _close = firstChar === '/';\n    feedPosition(position, str, _close ? 2 : 1);\n    var end = copyPosition(position);\n    state.tokens.push({ type: 'tag-end', close: _close, position: { end: end } });\n  }\n  return tagName;\n}\n\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#special-white-space\nvar whitespace = /\\s/;\nfunction isWhitespaceChar(char) {\n  return whitespace.test(char);\n}\n\nfunction lexTagName(state) {\n  var str = state.str,\n      position = state.position;\n\n  var len = str.length;\n  var start = position.index;\n  while (start < len) {\n    var char = str.charAt(start);\n    var isTagChar = !(isWhitespaceChar(char) || char === '/' || char === '>');\n    if (isTagChar) break;\n    start++;\n  }\n\n  var end = start + 1;\n  while (end < len) {\n    var _char = str.charAt(end);\n    var _isTagChar = !(isWhitespaceChar(_char) || _char === '/' || _char === '>');\n    if (!_isTagChar) break;\n    end++;\n  }\n\n  jumpPosition(position, str, end);\n  var tagName = str.slice(start, end);\n  state.tokens.push({\n    type: 'tag',\n    content: tagName\n  });\n  return tagName;\n}\n\nfunction lexTagAttributes(state) {\n  var str = state.str,\n      position = state.position,\n      tokens = state.tokens;\n\n  var cursor = position.index;\n  var quote = null; // null, single-, or double-quote\n  var wordBegin = cursor; // index of word start\n  var words = []; // \"key\", \"key=value\", \"key='value'\", etc\n  var len = str.length;\n  while (cursor < len) {\n    var char = str.charAt(cursor);\n    if (quote) {\n      var isQuoteEnd = char === quote;\n      if (isQuoteEnd) {\n        quote = null;\n      }\n      cursor++;\n      continue;\n    }\n\n    var isTagEnd = char === '/' || char === '>';\n    if (isTagEnd) {\n      if (cursor !== wordBegin) {\n        words.push(str.slice(wordBegin, cursor));\n      }\n      break;\n    }\n\n    var isWordEnd = isWhitespaceChar(char);\n    if (isWordEnd) {\n      if (cursor !== wordBegin) {\n        words.push(str.slice(wordBegin, cursor));\n      }\n      wordBegin = cursor + 1;\n      cursor++;\n      continue;\n    }\n\n    var isQuoteStart = char === '\\'' || char === '\"';\n    if (isQuoteStart) {\n      quote = char;\n      cursor++;\n      continue;\n    }\n\n    cursor++;\n  }\n  jumpPosition(position, str, cursor);\n\n  var wLen = words.length;\n  var type = 'attribute';\n  for (var i = 0; i < wLen; i++) {\n    var word = words[i];\n    var isNotPair = word.indexOf('=') === -1;\n    if (isNotPair) {\n      var secondWord = words[i + 1];\n      if (secondWord && (0, _compat.startsWith)(secondWord, '=')) {\n        if (secondWord.length > 1) {\n          var newWord = word + secondWord;\n          tokens.push({ type: type, content: newWord });\n          i += 1;\n          continue;\n        }\n        var thirdWord = words[i + 2];\n        i += 1;\n        if (thirdWord) {\n          var _newWord = word + '=' + thirdWord;\n          tokens.push({ type: type, content: _newWord });\n          i += 1;\n          continue;\n        }\n      }\n    }\n    if ((0, _compat.endsWith)(word, '=')) {\n      var _secondWord = words[i + 1];\n      if (_secondWord && !(0, _compat.stringIncludes)(_secondWord, '=')) {\n        var _newWord3 = word + _secondWord;\n        tokens.push({ type: type, content: _newWord3 });\n        i += 1;\n        continue;\n      }\n\n      var _newWord2 = word.slice(0, -1);\n      tokens.push({ type: type, content: _newWord2 });\n      continue;\n    }\n\n    tokens.push({ type: type, content: word });\n  }\n}\n\nvar push = [].push;\n\nfunction lexSkipTag(tagName, state) {\n  var str = state.str,\n      position = state.position,\n      tokens = state.tokens;\n\n  var safeTagName = tagName.toLowerCase();\n  var len = str.length;\n  var index = position.index;\n  while (index < len) {\n    var nextTag = str.indexOf('</', index);\n    if (nextTag === -1) {\n      lexText(state);\n      break;\n    }\n\n    var tagStartPosition = copyPosition(position);\n    jumpPosition(tagStartPosition, str, nextTag);\n    var tagState = { str: str, position: tagStartPosition, tokens: [] };\n    var name = lexTag(tagState);\n    if (safeTagName !== name.toLowerCase()) {\n      index = tagState.position.index;\n      continue;\n    }\n\n    if (nextTag !== position.index) {\n      var textStart = copyPosition(position);\n      jumpPosition(position, str, nextTag);\n      tokens.push({\n        type: 'text',\n        content: str.slice(textStart.index, nextTag),\n        position: {\n          start: textStart,\n          end: copyPosition(position)\n        }\n      });\n    }\n\n    push.apply(tokens, tagState.tokens);\n    jumpPosition(position, str, tagState.position.index);\n    break;\n  }\n}\n\n},{\"./compat\":1}],5:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parser;\nexports.hasTerminalParent = hasTerminalParent;\nexports.parse = parse;\n\nvar _compat = require('./compat');\n\nfunction parser(tokens, options) {\n  var root = { tagName: null, children: [] };\n  var state = { tokens: tokens, options: options, cursor: 0, stack: [root] };\n  parse(state);\n  return root.children;\n}\n\nfunction hasTerminalParent(tagName, stack, terminals) {\n  var tagParents = terminals[tagName];\n  if (tagParents) {\n    var currentIndex = stack.length - 1;\n    while (currentIndex >= 0) {\n      var parentTagName = stack[currentIndex].tagName;\n      if (parentTagName === tagName) {\n        break;\n      }\n      if ((0, _compat.arrayIncludes)(tagParents, parentTagName)) {\n        return true;\n      }\n      currentIndex--;\n    }\n  }\n  return false;\n}\n\nfunction parse(state) {\n  var tokens = state.tokens,\n      options = state.options;\n  var stack = state.stack;\n\n  var nodes = stack[stack.length - 1].children;\n  var len = tokens.length;\n  var cursor = state.cursor;\n\n  while (cursor < len) {\n    var token = tokens[cursor];\n    if (token.type !== 'tag-start') {\n      nodes.push(token);\n      cursor++;\n      continue;\n    }\n\n    var tagToken = tokens[++cursor];\n    cursor++;\n    var tagName = tagToken.content.toLowerCase();\n    if (token.close) {\n      var index = stack.length;\n      var didRewind = false;\n      while (--index > -1) {\n        if (stack[index].tagName === tagName) {\n          stack.splice(index);\n          didRewind = true;\n          break;\n        }\n      }\n      while (cursor < len) {\n        var endToken = tokens[cursor];\n        if (endToken.type !== 'tag-end') break;\n        cursor++;\n      }\n      if (didRewind) {\n        break;\n      } else {\n        continue;\n      }\n    }\n\n    var isClosingTag = (0, _compat.arrayIncludes)(options.closingTags, tagName);\n    var shouldRewindToAutoClose = isClosingTag;\n    if (shouldRewindToAutoClose) {\n      var terminals = options.closingTagAncestorBreakers;\n\n      shouldRewindToAutoClose = !hasTerminalParent(tagName, stack, terminals);\n    }\n\n    if (shouldRewindToAutoClose) {\n      // rewind the stack to just above the previous\n      // closing tag of the same name\n      var currentIndex = stack.length - 1;\n      while (currentIndex > 0) {\n        if (tagName === stack[currentIndex].tagName) {\n          stack = stack.slice(0, currentIndex);\n          var previousIndex = currentIndex - 1;\n          nodes = stack[previousIndex].children;\n          break;\n        }\n        currentIndex = currentIndex - 1;\n      }\n    }\n\n    var attributes = [];\n    var attrToken = void 0;\n    while (cursor < len) {\n      attrToken = tokens[cursor];\n      if (attrToken.type === 'tag-end') break;\n      attributes.push(attrToken.content);\n      cursor++;\n    }\n\n    cursor++;\n    var children = [];\n    nodes.push({\n      type: 'element',\n      tagName: tagToken.content,\n      attributes: attributes,\n      children: children\n    });\n\n    var hasChildren = !(attrToken.close || (0, _compat.arrayIncludes)(options.voidTags, tagName));\n    if (hasChildren) {\n      stack.push({ tagName: tagName, children: children });\n      var innerState = { tokens: tokens, options: options, cursor: cursor, stack: stack };\n      parse(innerState);\n      cursor = innerState.cursor;\n    }\n  }\n  state.cursor = cursor;\n}\n\n},{\"./compat\":1}],6:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.formatAttributes = formatAttributes;\nexports.toHTML = toHTML;\n\nvar _compat = require('./compat');\n\nfunction formatAttributes(attributes) {\n  return Object.keys(attributes).reduce(function (attrs, key) {\n    var value = attributes[key];\n    if (!value) return attrs + ' ' + key;else if (key === 'style' && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n      var styles = '';\n      Object.keys(value).map(function (name) {\n        styles += name + ':' + value[name] + ';';\n      });\n      var quoteEscape = styles.indexOf('\\'') !== -1;\n      var quote = quoteEscape ? '\"' : '\\'';\n      return attrs + ' ' + key + '=' + quote + styles + quote;\n    }\n\n    if (typeof value === 'string') {\n      var _quoteEscape = value.indexOf('\\'') !== -1;\n      var _quote = _quoteEscape ? '\"' : '\\'';\n      return attrs + ' ' + key + '=' + _quote + value + _quote;\n    }\n  }, '');\n}\n\nfunction toHTML(tree, options) {\n  if (typeof tree === 'string') return tree;\n  return tree && tree.map(function (node) {\n    if (typeof node === 'string') return node;\n    if (node.type === 'comment') return '<!--' + node.content + '-->';\n    var tagName = node[0];\n    var attributes = node[1];\n    var children = node[2];\n\n    var isSelfClosing = (0, _compat.arrayIncludes)(options.voidTags, tagName.toLowerCase());\n    return isSelfClosing ? '<' + tagName + formatAttributes(attributes) + '>' : '<' + tagName + formatAttributes(attributes) + '>' + (toHTML(children, options) || '') + '</' + tagName + '>';\n  }).join('');\n}\n\nexports.default = { toHTML: toHTML };\n\n},{\"./compat\":1}],7:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n  Tags which contain arbitary non-parsed content\n  For example: <script> JavaScript should not be parsed\n*/\nvar childlessTags = exports.childlessTags = ['style', 'script', 'template'];\n\n/*\n  Tags which auto-close because they cannot be nested\n  For example: <p>Outer<p>Inner is <p>Outer</p><p>Inner</p>\n*/\nvar closingTags = exports.closingTags = ['html', 'head', 'body', 'p', 'dt', 'dd', 'li', 'option', 'thead', 'th', 'tbody', 'tr', 'td', 'tfoot', 'colgroup'];\n\n/*\n  Closing tags which have ancestor tags which\n  may exist within them which prevent the\n  closing tag from auto-closing.\n  For example: in <li><ul><li></ul></li>,\n  the top-level <li> should not auto-close.\n*/\nvar closingTagAncestorBreakers = exports.closingTagAncestorBreakers = {\n  li: ['ul', 'ol', 'menu'],\n  dt: ['dl'],\n  dd: ['dl'],\n  tbody: ['table'],\n  thead: ['table'],\n  tfoot: ['table'],\n  tr: ['table'],\n  td: ['table']\n\n  /*\n    Tags which do not need the closing tag\n    For example: <img> does not need </img>\n  */\n};var voidTags = exports.voidTags = ['!doctype', 'area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr'];\n\n},{}]},{},[3])(3)\n});"],"file":"symplasm.js"}