var symplasm =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/scripts/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/scripts/compat.js":
/*!*******************************!*\
  !*** ./src/scripts/compat.js ***!
  \*******************************/
/*! exports provided: startsWith, endsWith, stringIncludes, isRealNaN, arrayIncludes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"startsWith\", function() { return startsWith; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"endsWith\", function() { return endsWith; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stringIncludes\", function() { return stringIncludes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isRealNaN\", function() { return isRealNaN; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"arrayIncludes\", function() { return arrayIncludes; });\nfunction startsWith (str, searchString, position) {\n  return str.substr(position || 0, searchString.length) === searchString\n}\n\nfunction endsWith (str, searchString, position) {\n  const index = (position || str.length) - searchString.length\n  const lastIndex = str.lastIndexOf(searchString, index)\n  return lastIndex !== -1 && lastIndex === index\n}\n\nfunction stringIncludes (str, searchString, position) {\n  return str.indexOf(searchString, position || 0) !== -1\n}\n\nfunction isRealNaN (x) {\n  return typeof x === 'number' && isNaN(x)\n}\n\nfunction arrayIncludes (array, searchElement, position) {\n  const len = array.length\n  if (len === 0) return false\n\n  const lookupIndex = position | 0\n  const isNaNElement = isRealNaN(searchElement)\n  let searchIndex = lookupIndex >= 0 ? lookupIndex : len + lookupIndex\n  while (searchIndex < len) {\n    const element = array[searchIndex++]\n    if (element === searchElement) return true\n    if (isNaNElement && isRealNaN(element)) return true\n  }\n\n  return false\n}\n\n\n//# sourceURL=webpack://symplasm/./src/scripts/compat.js?");

/***/ }),

/***/ "./src/scripts/format.js":
/*!*******************************!*\
  !*** ./src/scripts/format.js ***!
  \*******************************/
/*! exports provided: formatFS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"formatFS\", function() { return formatFS; });\n/* harmony import */ var _prop_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./prop_map */ \"./src/scripts/prop_map.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ \"./src/scripts/helpers.js\");\n\n\n\n\nlet options = {\n  root: {\n    0: 'div',\n  },\n  tagConvert: {},\n  attrKeyConvert: {},\n  attrValueConvert: {},\n  attrKeyAdd: {},\n  attrCamelCase: false,\n  trim: false,\n  lowerCaseTag: true,\n  comments: true\n}\n\nlet selectorCheck = {\n  tagConvert: {},\n  attrKeyConvert: {},\n  attrValueConvert: {},\n  attrKeyAdd: {},\n}\nlet attrArrEmpty = true\nconst domTagAction = '$$DOM_TAG_NAME'\n\nconst convertBlock = (block, parent, nodes, children, tree) => {\n  const data = selectorCheck.tagConvert[block[0]]\n    ? runAction({\n        action: selectorCheck.tagConvert[block[0]],\n        node: block,\n        key: domTagAction,\n        value: block[0],\n        nodes,\n        children\n      }, 'value')\n    : block[0]\n  if(typeof data === 'string') block[0] = data\n  if(typeof data === 'object') block = data\n  \n \n  block[1] = typeof block[1] === 'object'\n    ? Object.keys(block[1]).reduce((attrs, key) => {\n        let useKey = selectorCheck.attrKeyConvert[key]\n          ? runAction({\n              action: selectorCheck.attrKeyConvert[key],\n              node: block,\n              value: block[1][key],\n              key,\n              nodes,\n              children\n            }, 'key')\n          : key\n        \n        useKey = options.attrCamelCase && _prop_map__WEBPACK_IMPORTED_MODULE_0__[\"propMap\"][useKey] || useKey\n\n        if(useKey && block[1][key]){\n          attrs[useKey] = selectorCheck.attrValueConvert[key]\n            ? runAction({\n                action: selectorCheck.attrValueConvert[key],\n                node: block,\n                value: block[1][key],\n                key,\n                nodes,\n                children\n              }, 'value')\n            : typeof block[1][key] === 'string'\n              ? Object(_helpers__WEBPACK_IMPORTED_MODULE_1__[\"unquote\"])(block[1][key])\n              : block[1][key]\n        }\n\n        return attrs\n      }, {})\n    : {}\n\n \n  if(block[2] &&  typeof block[2] !== 'string' && block[2].length){\n    block[2] = block[2].map(child => {\n      return convertBlock(child, block, nodes, children, tree)\n    })\n  }\n\n  return tree && allElementsCB(block, parent, tree) || block\n}\n\nconst buildBlock = (org, added, nodes, children, parent) => {\n  org[0] = added[0]\n  org[1] = { ...org[1], ...added[1] }\n  if(added[2]) org[2] = added[2]\n  return convertBlock(org, parent, nodes, children)\n}\n\nconst tagConvert = ({ action, node, value, nodes, children, parent, block }) => {\n\n  const tagName = node[0]\n  if(!tagName) return block\n  block[0] = options.lowerCaseTag\n    ? tagName.toLowerCase()\n    : tagName\n\n  if(typeof action === 'function'){\n    let data = runAction({\n      key: domTagAction,\n      value: block[0],\n      action,\n      node,\n      nodes,\n      children\n    }, 'value')\n    if(!data) return block\n    if(typeof data === 'string') data = { 0: data }\n    \n    if(typeof data === 'object')\n      block = buildBlock(block, data, nodes, children, parent)\n  }\n  else if(typeof action === 'object' && !Array.isArray(action) && action[0]){\n    block = buildBlock(block, action, nodes, children, parent)\n  }\n  else {\n    const data = runAction({\n      key: domTagAction,\n      value: block[0],\n      action,\n      node,\n      nodes,\n      children\n    }, 'value')\n    if(typeof data === 'string') block[0] = data\n    if(typeof data === 'object'){\n      block = buildBlock(block, data, nodes, children, parent)\n    }\n  }\n  return block\n}\n\n\nconst format = ({ parent, childs, nodes, tree, ...args }) => {\n  return childs\n    ? childs.reduce((children, node) => {\n        nodes = nodes || childs\n        const child = node.type === 'text' || node.type === 'comment'\n          ? filterFS(node, parent)\n          : formatNode({\n            node,\n            childs,\n            nodes,\n            children,\n            tree,\n            parent\n          })\n        child && children.push(child)\n        return children\n      }, [])\n    : []\n}\n\nconst formatNode = ({ node, nodes, children, tree, parent }) => {\n \n \n \n  const block = selectorCheck.tagConvert[node[0]]\n    ? tagConvert({\n        action: selectorCheck.tagConvert[node[0]],\n        block: {},\n        value: node[0],\n        node,\n        nodes,\n        children,\n        parent\n      })\n    : { 0: node[0] }\n\n \n  const attrs = formatAttributes({\n    attributes: node[1],\n    node,\n    nodes,\n    children\n  })\n\n \n \n  block[1] = { ...attrs, ...block[1] }\n\n  return allElementsCB(\n   \n    Object(_helpers__WEBPACK_IMPORTED_MODULE_1__[\"addChildren\"])(\n      block,\n     \n      format({\n        tree,\n        childs: node[2],\n        parent: block,\n        nodes,\n        children\n      })\n    ),\n    parent,\n    tree\n  )\n  \n  \n}\n\nconst formatAttributes = (args) => {\n  const { node, nodes, children } = args\n  let { attributes } = args\n  attributes = attributes || {}\n  const attrs = {}\n\n  Object.keys(attributes).map(item => {\n    const parts = [ item, attributes[item]]\n    \n    if(selectorCheck.attrKeyConvert[parts[0]] === null) return\n    \n    let key = selectorCheck.attrKeyConvert[parts[0]]\n      ? runAction({\n          action: selectorCheck.attrKeyConvert[parts[0]],\n          key: parts[0],\n          value: parts[1],\n          node,\n          nodes,\n          children\n        }, 'key')\n      : parts[0]\n    \n    key = options.attrCamelCase && _prop_map__WEBPACK_IMPORTED_MODULE_0__[\"propMap\"][key] || key\n    \n    const value = typeof parts[1] === 'string' || typeof parts[1] === 'object'\n      ? formatValue({\n          key: parts[0],\n          value: parts[1],\n          node,\n          nodes,\n          children\n        })\n      : null\n\n    if(key){\n      if((key === 'className' || key === 'class') && value === '') attrs[key] = ''\n      if(key === 'id' && !value) return\n      attrs[key] = value || value === false\n        ? value\n        : true\n    }\n\n  })\n  \n  if(attrArrEmpty) return attrs\n  \n  return addAttribute({\n    node,\n    attrs,\n    nodes,\n    children\n  })\n  \n}\n\nconst formatValue = (args) => {\n  const { node, key, value, nodes, children } = args\n  const updatedVal = key === 'style' && typeof value === 'string'\n    ? Object(_helpers__WEBPACK_IMPORTED_MODULE_1__[\"convertStyle\"])(Object(_helpers__WEBPACK_IMPORTED_MODULE_1__[\"unquote\"])(value))\n    : selectorCheck.attrValueConvert[key]\n      ? runAction({\n          action: selectorCheck.attrValueConvert[key],\n          value: Object(_helpers__WEBPACK_IMPORTED_MODULE_1__[\"unquote\"])(value),\n          node,\n          key,\n          nodes,\n          children\n        }, 'value')\n      : typeof value === 'string' && Object(_helpers__WEBPACK_IMPORTED_MODULE_1__[\"unquote\"])(value) || value\n\n  if(updatedVal === 'true') return true\n  if(updatedVal === 'false') return false\n  return updatedVal\n}\n\n\nconst runAction = (args, def) => {\n  const { action, node, key, value, nodes, children } = args\n  \n  switch(typeof action){\n    case 'string':\n      return action || args[def]\n    case 'function':\n      return action({\n        0: node[0],\n        1: node[1],\n        2: node[2]\n      }, key, value, nodes, children, options) || args[def]\n      \n    case 'object':\n      let updateVal\n     \n      const tagType = node[0]\n       if(!tagType) return args[def]\n      \n     \n      const nodeAttrs = node[1]\n      if(!nodeAttrs) return args[def]\n      \n     \n      const selector = action[tagType]\n     \n      if(!selector) return args[def]\n     \n      updateVal = selector.all || null\n      const selectKeys = Object.keys(selector)\n\n      if(\n       \n        selector.all && selectKeys.length > 1 ||\n       \n        !selector.all  && selectKeys.length >= 1\n      ){\n       \n        if(!nodeAttrs) return args[def]\n       \n        let setSelector\n        \n        Object.keys(selector).map(key => {\n         \n          if(setSelector || (!nodeAttrs[key] && nodeAttrs[key] !== '')) return\n          \n          if(nodeAttrs[key] === \"true\" && !selector[key][nodeAttrs[key]] && selector[key]['']){\n            updateVal = selector[key]['']\n            setSelector = true\n          }\n          else if(selector[key][nodeAttrs[key]]){\n            updateVal = selector[key][nodeAttrs[key]]\n            setSelector = true\n          }\n        })\n      }\n\n      if(updateVal){\n       \n        if(typeof updateVal === 'string' || typeof updateVal === 'object') return updateVal\n        else if(typeof updateVal === 'function'){\n          return updateVal({\n            0: node[0],\n            1: node[1],\n            2: node[2]\n          }, key, value, nodes, children, options) || args[def]\n        }\n      }\n     \n      return args[def]\n\n    default:\n      return action || args[def]\n  }\n}\n\n\nconst addAttribute = ({ node, attrs, nodes, children }) => {\n  Object.keys(selectorCheck.attrKeyAdd).map(key => {\n    const value = runAction({\n      action: selectorCheck.attrKeyAdd[key],\n      key,\n      node,\n      nodes,\n      children\n    })\n\n    if(value) attrs[key] = value\n  })\n\n  return attrs\n}\n\n\nconst filterFS = (node) => {\n  let start = ''\n  let end = ''\n  let text = node.content\n\n  if (node.type === 'comment') {\n    if(!options.comments) return null\n    start = '<!--'\n    end = '-->'\n  }\n  if (options.trim) {\n    return node.content.trim() !== '\\n' && node.content.replace(/\\s/g, '').length > 0\n      ? start + node.content.trim() + end\n      : null\n  }\n  return text\n    ? start + text + end\n    : null\n}\n\nconst allElementsCB = (block, parent, tree) => {\n  return typeof options.allElements === 'function'\n    ? options.allElements(block, parent, tree) || block\n    : block\n}\n\nconst formatFS = (nodes, _options) => {\n  let rootFS = { ...options.root, ..._options.root }\n  options = { ...options, ..._options }\n\n  selectorCheck = Object(_helpers__WEBPACK_IMPORTED_MODULE_1__[\"setupSelectors\"])(selectorCheck, options)\n  attrArrEmpty = Object.keys(options.attrKeyAdd).length === 0\n  \n  if(selectorCheck.tagConvert[rootFS[0]]){\n    rootFS = tagConvert({\n      action: selectorCheck.tagConvert[rootFS[0]],\n      block: rootFS,\n      value: rootFS[0],\n      node: rootFS,\n      children: nodes,\n      nodes,\n      rootFS,\n    })\n  }\n\n  rootFS[1] = formatAttributes({\n    attributes: rootFS[1],\n    node: rootFS,\n    children: nodes,\n    nodes\n  })\n\n  rootFS[2] = Array.isArray(rootFS[2])\n  ? rootFS[2].map(child => {\n      return convertBlock(child, rootFS, nodes, nodes, rootFS)\n    })\n  : []\n\n  const builtRoot = Object(_helpers__WEBPACK_IMPORTED_MODULE_1__[\"addChildren\"])(rootFS, format({\n    childs: nodes,\n    parent: rootFS,\n    tree: rootFS,\n  }))\n\n  return allElementsCB(builtRoot, builtRoot, builtRoot)\n}\n\n//# sourceURL=webpack://symplasm/./src/scripts/format.js?");

/***/ }),

/***/ "./src/scripts/helpers.js":
/*!********************************!*\
  !*** ./src/scripts/helpers.js ***!
  \********************************/
/*! exports provided: addChildren, convertCase, convertStyle, setupSelectors, splitKeyValue, unquote */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addChildren\", function() { return addChildren; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"convertCase\", function() { return convertCase; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"convertStyle\", function() { return convertStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setupSelectors\", function() { return setupSelectors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"splitKeyValue\", function() { return splitKeyValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unquote\", function() { return unquote; });\nconst selectTypes = [[ 'class', '.'], [ 'id', '#'], [ 'data', '[']]\n\nconst buildElSelectors = (selCheck, selAttr, key, attr) => {\n \n  let elSelect = selAttr && selAttr.selector\n  \n  if(key !== 'tagConvert'){\n   \n   \n   \n    if(typeof selAttr === 'string' || typeof selAttr === 'function'){\n      selCheck[key][attr] = selAttr\n      return\n    }\n\n   \n   \n    if(selAttr && !elSelect && Object.keys(selAttr).length){\n      elSelect = {}\n      Object.keys(selAttr).map(key => {\n        elSelect[key] = selAttr[key]\n      })\n    }\n\n    if(!elSelect){\n      if(selAttr === null) selCheck[key][attr] = null\n      return\n    }\n   \n    selCheck[key][attr] = selCheck[key][attr] || {}\n  }\n  else {\n    elSelect = {}\n    elSelect[attr] = selAttr\n  }\n\n  return elSelect\n}\n\n\nconst findSelector = (hasSelectors, elSelectors, select, props, tag) => {\n  let el\n \n \n  selectTypes.map(type => {\n   \n    if(tag.indexOf(type[1]) !== -1){\n      const split = tag.split(type[1])\n      if(type[0] === 'data'){\n        const dataSplit = split[1].split('=')\n        const key = clean(dataSplit[0].replace(']', ''))\n        const dataKey = dataSplit[1] && clean(dataSplit[1].replace(']', '')) || ''\n        props[key] = { ...props[key], [dataKey]: elSelectors[select] }\n      }\n      else {\n        props[type[0]] = {\n          ...props[type[0]],\n          [clean(split[1])]: elSelectors[select]\n        }\n      }\n\n      el = clean(split[0])\n      if(el.indexOf('.') !== -1 || el.indexOf('#') !== -1 || el.indexOf('[') !== -1 ){\n        console.warn(`Error: \"${el}\" is not formatted correctly. It contains one of \". # [\"`)\n      }\n     \n      hasSelectors.push(true)\n    }\n  })\n\n  return el\n}\n\nconst setupSelectors = (selCheck, options) => {\n  const selectorArr = Object.keys(selCheck)\n  Object.keys(options).map(key => {\n   \n    if(selectorArr.indexOf(key) === -1) return\n    \n    const props = {}\n    Object.keys(options[key]).map(attr => {\n     \n      const attribute = options[key][attr]\n      let elSelectors = buildElSelectors(selCheck, attribute, key, attr)\n      if(!elSelectors) return\n\n     \n      const isArr = Array.isArray(elSelectors)\n     \n      if(isArr){\n       \n       \n        if(!options[key][attr].value) return\n       \n        selCheck[key][attr].value = options[key][attr].value\n      }\n\n      Object.keys(elSelectors).map(select => {\n       \n        const tags = isArr && elSelectors[select] || select\n       \n        const allTags = tags.split(',')\n       \n        allTags.map(_tag => {\n          const tag = clean(_tag)\n          const hasSelectors = []\n          let el = findSelector(hasSelectors, elSelectors, select, props, tag)\n         \n         \n         \n         \n          if(hasSelectors.indexOf(true) !== -1){\n            const loc = key !== 'tagConvert'\n              ? attr\n              : el\n            selCheck[key] = selCheck[key] || {}\n            selCheck[key][loc] = selCheck[key][loc] || {}\n            selCheck[key][loc][el] = { ...selCheck[key][loc][el], ...props }\n          }\n         \n          else {\n            const loc = key !== 'tagConvert'\n              ? attr\n              : tag\n              \n            selCheck[key] = selCheck[key] || {}\n            selCheck[key][loc] = selCheck[key][loc] || {}\n            selCheck[key][loc][tag] = selCheck[key][loc][tag] || {}\n            selCheck[key][loc][tag].all = elSelectors[select]\n          }\n        })\n      })\n    })\n  })\n\n  return selCheck\n}\n\nconst addChildren = (block, childs) => {\n  const addChilds = childs.length === 1 && typeof childs[0] === 'string'\n    ? childs[0]\n    : childs.length && childs || null\n\n  if(addChilds) {\n    if(!block[2]) block[2] = addChilds\n    else if(Array.isArray(block[2])) block[2] = block[2].concat(addChilds)\n    else block[2] = [block[2]].concat(addChilds)\n  }\n  return block\n}\n\nconst convertCase = text => {\n  let converted = ''\n  const text_split = text.split('-')\n  if(!text_split.length) return text\n  converted += text_split.shift()\n  text_split.map(val => {\n    converted += val.charAt(0).toUpperCase() + val.slice(1)\n  })\n  return converted\n}\n\nconst convertStyle = styles => {\n  const valObj = {}\n  const val_split = styles.trim().split(';')\n  \n  Array.isArray(val_split) &&\n    val_split[0].trim() !== '' &&\n    val_split.map(item => {\n      if (item.indexOf(':') !== -1) {\n        const item_split = item.split(':')\n        if (Array.isArray(item_split) && item_split.length === 2) {\n          if (item_split[0].trim() !== '' && item_split[1].trim() !== '') {\n            valObj[convertCase(item_split[0].trim())] = item_split[1].trim()\n          }\n        }\n      }\n    })\n\n  return valObj\n}\n\nconst splitKeyValue = (str, sep) => {\n  const idx = str.indexOf(sep)\n  if (idx === -1) return [str]\n  return [str.slice(0, idx), str.slice(idx + sep.length)]\n}\n\nconst clean = (str) => {\n  return str && unquote(str.trim()).trim() || ''\n}\n\nconst unquote = str => {\n  const car = str.charAt(0)\n  const end = str.length - 1\n  const isQuoteStart = car === '\"' || car === \"'\"\n  if (isQuoteStart && car === str.charAt(end)) {\n    return str.slice(1, end)\n  }\n  return str\n}\n\n\n\n//# sourceURL=webpack://symplasm/./src/scripts/helpers.js?");

/***/ }),

/***/ "./src/scripts/index.js":
/*!******************************!*\
  !*** ./src/scripts/index.js ***!
  \******************************/
/*! exports provided: parseDefaults, parse, stringify */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseDefaults\", function() { return parseDefaults; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parse\", function() { return parse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stringify\", function() { return stringify; });\n/* harmony import */ var _lexer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lexer */ \"./src/scripts/lexer.js\");\n/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parser */ \"./src/scripts/parser.js\");\n/* harmony import */ var _stringify__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify */ \"./src/scripts/stringify.js\");\n/* harmony import */ var _format__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./format */ \"./src/scripts/format.js\");\n/* harmony import */ var _tags__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tags */ \"./src/scripts/tags.js\");\n\n\n\n\n\n\n\n\nconst parseDefaults = {\n  voidTags: _tags__WEBPACK_IMPORTED_MODULE_4__[\"voidTags\"],\n  closingTags: _tags__WEBPACK_IMPORTED_MODULE_4__[\"closingTags\"],\n  childlessTags: _tags__WEBPACK_IMPORTED_MODULE_4__[\"childlessTags\"],\n  closingTagAncestorBreakers: _tags__WEBPACK_IMPORTED_MODULE_4__[\"closingTagAncestorBreakers\"],\n  includePositions: false\n}\n\nfunction parse (str) {\n  let options = Object.assign(parseDefaults, arguments[1])\n  const tokens = Object(_lexer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(str, options)\n  const nodes = Object(_parser__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(tokens, options)\n  return Object(_format__WEBPACK_IMPORTED_MODULE_3__[\"formatFS\"])(nodes, options)\n}\n\nfunction stringify (ast) {\n  let options = parseDefaults\n  options.hasOpts = false\n  if(arguments[1]){\n    options = Object.assign(parseDefaults, arguments[1])\n    options.hasOpts = true\n  }\n\n  return Array.isArray(ast)\n    ? Object(_stringify__WEBPACK_IMPORTED_MODULE_2__[\"toHTML\"])(ast, options)\n    : Object(_stringify__WEBPACK_IMPORTED_MODULE_2__[\"toHTML\"])([ast], options)\n}\n\n//# sourceURL=webpack://symplasm/./src/scripts/index.js?");

/***/ }),

/***/ "./src/scripts/lexer.js":
/*!******************************!*\
  !*** ./src/scripts/lexer.js ***!
  \******************************/
/*! exports provided: feedPosition, jumpPosition, makeInitialPosition, copyPosition, default, lex, findTextEnd, lexText, lexComment, lexTag, isWhitespaceChar, lexTagName, lexTagAttributes, lexSkipTag */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"feedPosition\", function() { return feedPosition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"jumpPosition\", function() { return jumpPosition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeInitialPosition\", function() { return makeInitialPosition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copyPosition\", function() { return copyPosition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return lexer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lex\", function() { return lex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findTextEnd\", function() { return findTextEnd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lexText\", function() { return lexText; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lexComment\", function() { return lexComment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lexTag\", function() { return lexTag; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isWhitespaceChar\", function() { return isWhitespaceChar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lexTagName\", function() { return lexTagName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lexTagAttributes\", function() { return lexTagAttributes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lexSkipTag\", function() { return lexSkipTag; });\n/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compat */ \"./src/scripts/compat.js\");\n\n\nfunction feedPosition (position, str, len) {\n  const start = position.index\n  const end = position.index = start + len\n  for (let i = start; i < end; i++) {\n    const char = str.charAt(i)\n    if (char === '\\n') {\n      position.line++\n      position.column = 0\n    } else {\n      position.column++\n    }\n  }\n}\n\nfunction jumpPosition (position, str, end) {\n  const len = end - position.index\n  return feedPosition(position, str, len)\n}\n\nfunction makeInitialPosition () {\n  return {\n    index: 0,\n    column: 0,\n    line: 0\n  }\n}\n\nfunction copyPosition (position) {\n  return {\n    index: position.index,\n    line: position.line,\n    column: position.column\n  }\n}\n\nfunction lexer (str, options) {\n  const state = {\n    str,\n    options,\n    position: makeInitialPosition(),\n    tokens: []\n  }\n  lex(state)\n  return state.tokens\n}\n\nfunction lex (state) {\n  const {str, options: {childlessTags}} = state\n  const len = str.length\n  while (state.position.index < len) {\n    const start = state.position.index\n    lexText(state)\n    if (state.position.index === start) {\n      const isComment = Object(_compat__WEBPACK_IMPORTED_MODULE_0__[\"startsWith\"])(str, '!--', start + 1)\n      if (isComment) {\n        lexComment(state)\n      } else {\n        const tagName = lexTag(state)\n        const safeTag = tagName.toLowerCase()\n        if (Object(_compat__WEBPACK_IMPORTED_MODULE_0__[\"arrayIncludes\"])(childlessTags, safeTag)) {\n          lexSkipTag(tagName, state)\n        }\n      }\n    }\n  }\n}\n\nconst alphanumeric = /[A-Za-z0-9]/\nfunction findTextEnd (str, index) {\n  while (true) {\n    const textEnd = str.indexOf('<', index)\n    if (textEnd === -1) {\n      return textEnd\n    }\n    const char = str.charAt(textEnd + 1)\n    if (char === '/' || char === '!' || alphanumeric.test(char)) {\n      return textEnd\n    }\n    index = textEnd + 1\n  }\n}\n\nfunction lexText (state) {\n  const type = 'text'\n  const {str, position} = state\n  let textEnd = findTextEnd(str, position.index)\n  if (textEnd === position.index) return\n  if (textEnd === -1) {\n    textEnd = str.length\n  }\n\n  const start = copyPosition(position)\n  const content = str.slice(position.index, textEnd)\n  jumpPosition(position, str, textEnd)\n  const end = copyPosition(position)\n  state.tokens.push({type, content, position: {start, end}})\n}\n\nfunction lexComment (state) {\n  const {str, position} = state\n  const start = copyPosition(position)\n  feedPosition(position, str, 4)\n  let contentEnd = str.indexOf('-->', position.index)\n  let commentEnd = contentEnd + 3\n  if (contentEnd === -1) {\n    contentEnd = commentEnd = str.length\n  }\n\n  const content = str.slice(position.index, contentEnd)\n  jumpPosition(position, str, commentEnd)\n  state.tokens.push({\n    type: 'comment',\n    content,\n    position: {\n      start,\n      end: copyPosition(position)\n    }\n  })\n}\n\nfunction lexTag (state) {\n  const {str, position} = state\n  {\n    const secondChar = str.charAt(position.index + 1)\n    const close = secondChar === '/'\n    const start = copyPosition(position)\n    feedPosition(position, str, close ? 2 : 1)\n    state.tokens.push({type: 'tag-start', close, position: {start}})\n  }\n  const tagName = lexTagName(state)\n  lexTagAttributes(state)\n  {\n    const firstChar = str.charAt(position.index)\n    const close = firstChar === '/'\n    feedPosition(position, str, close ? 2 : 1)\n    const end = copyPosition(position)\n    state.tokens.push({type: 'tag-end', close, position: {end}})\n  }\n  return tagName\n}\n\nconst whitespace = /\\s/\nfunction isWhitespaceChar (char) {\n  return whitespace.test(char)\n}\n\nfunction lexTagName (state) {\n  const {str, position} = state\n  const len = str.length\n  let start = position.index\n  while (start < len) {\n    const char = str.charAt(start)\n    const isTagChar = !(isWhitespaceChar(char) || char === '/' || char === '>')\n    if (isTagChar) break\n    start++\n  }\n\n  let end = start + 1\n  while (end < len) {\n    const char = str.charAt(end)\n    const isTagChar = !(isWhitespaceChar(char) || char === '/' || char === '>')\n    if (!isTagChar) break\n    end++\n  }\n\n  jumpPosition(position, str, end)\n  const tagName = str.slice(start, end)\n  state.tokens.push({\n    type: 'tag',\n    content: tagName\n  })\n  return tagName\n}\n\nfunction lexTagAttributes (state) {\n  const {str, position, tokens} = state\n  let cursor = position.index\n  let quote = null\n  let wordBegin = cursor\n  const words = []\n  const len = str.length\n  while (cursor < len) {\n    const char = str.charAt(cursor)\n    if (quote) {\n      const isQuoteEnd = char === quote\n      if (isQuoteEnd) {\n        quote = null\n      }\n      cursor++\n      continue\n    }\n\n    const isTagEnd = char === '/' || char === '>'\n    if (isTagEnd) {\n      if (cursor !== wordBegin) {\n        words.push(str.slice(wordBegin, cursor))\n      }\n      break\n    }\n\n    const isWordEnd = isWhitespaceChar(char)\n    if (isWordEnd) {\n      if (cursor !== wordBegin) {\n        words.push(str.slice(wordBegin, cursor))\n      }\n      wordBegin = cursor + 1\n      cursor++\n      continue\n    }\n\n    const isQuoteStart = char === '\\'' || char === '\"'\n    if (isQuoteStart) {\n      quote = char\n      cursor++\n      continue\n    }\n\n    cursor++\n  }\n  jumpPosition(position, str, cursor)\n\n  const wLen = words.length\n  const type = 'attribute'\n  for (let i = 0; i < wLen; i++) {\n    const word = words[i]\n    const isNotPair = word.indexOf('=') === -1\n    if (isNotPair) {\n      const secondWord = words[i + 1]\n      if (secondWord && Object(_compat__WEBPACK_IMPORTED_MODULE_0__[\"startsWith\"])(secondWord, '=')) {\n        if (secondWord.length > 1) {\n          const newWord = word + secondWord\n          tokens.push({type, content: newWord})\n          i += 1\n          continue\n        }\n        const thirdWord = words[i + 2]\n        i += 1\n        if (thirdWord) {\n          const newWord = word + '=' + thirdWord\n          tokens.push({type, content: newWord})\n          i += 1\n          continue\n        }\n      }\n    }\n    if (Object(_compat__WEBPACK_IMPORTED_MODULE_0__[\"endsWith\"])(word, '=')) {\n      const secondWord = words[i + 1]\n      if (secondWord && !Object(_compat__WEBPACK_IMPORTED_MODULE_0__[\"stringIncludes\"])(secondWord, '=')) {\n        const newWord = word + secondWord\n        tokens.push({type, content: newWord})\n        i += 1\n        continue\n      }\n\n      const newWord = word.slice(0, -1)\n      tokens.push({type, content: newWord})\n      continue\n    }\n\n    tokens.push({type, content: word})\n  }\n}\n\nconst push = [].push\n\nfunction lexSkipTag (tagName, state) {\n  const {str, position, tokens} = state\n  const safeTagName = tagName.toLowerCase()\n  const len = str.length\n  let index = position.index\n  while (index < len) {\n    const nextTag = str.indexOf('</', index)\n    if (nextTag === -1) {\n      lexText(state)\n      break\n    }\n\n    const tagStartPosition = copyPosition(position)\n    jumpPosition(tagStartPosition, str, nextTag)\n    const tagState = {str, position: tagStartPosition, tokens: []}\n    const name = lexTag(tagState)\n    if (safeTagName !== name.toLowerCase()) {\n      index = tagState.position.index\n      continue\n    }\n\n    if (nextTag !== position.index) {\n      const textStart = copyPosition(position)\n      jumpPosition(position, str, nextTag)\n      tokens.push({\n        type: 'text',\n        content: str.slice(textStart.index, nextTag),\n        position: {\n          start: textStart,\n          end: copyPosition(position)\n        }\n      })\n    }\n\n    push.apply(tokens, tagState.tokens)\n    jumpPosition(position, str, tagState.position.index)\n    break\n  }\n}\n\n\n//# sourceURL=webpack://symplasm/./src/scripts/lexer.js?");

/***/ }),

/***/ "./src/scripts/parser.js":
/*!*******************************!*\
  !*** ./src/scripts/parser.js ***!
  \*******************************/
/*! exports provided: default, hasTerminalParent, parse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return parser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hasTerminalParent\", function() { return hasTerminalParent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parse\", function() { return parse; });\n/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compat */ \"./src/scripts/compat.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ \"./src/scripts/helpers.js\");\n\n\n\n\nfunction parser (tokens, options) {\n  const root = {tagName: null, children: []}\n  const state = {tokens, options, cursor: 0, stack: [root]}\n  parse(state)\n  return root.children\n}\n\nfunction hasTerminalParent (tagName, stack, terminals) {\n  const tagParents = terminals[tagName]\n  if (tagParents) {\n    let currentIndex = stack.length - 1\n    while (currentIndex >= 0) {\n      const parentTagName = stack[currentIndex].tagName\n      if (parentTagName === tagName) {\n        break\n      }\n      if (Object(_compat__WEBPACK_IMPORTED_MODULE_0__[\"arrayIncludes\"])(tagParents, parentTagName)) {\n        return true\n      }\n      currentIndex--\n    }\n  }\n  return false\n}\n\nfunction parse (state) {\n  const {tokens, options} = state\n  let {stack} = state\n  let nodes = stack[stack.length - 1].children\n  const len = tokens.length\n  let {cursor} = state\n  while (cursor < len) {\n    const token = tokens[cursor]\n    if (token.type !== 'tag-start') {\n      nodes.push(token)\n      cursor++\n      continue\n    }\n\n    const tagToken = tokens[++cursor]\n    cursor++\n    const tagName = tagToken.content.toLowerCase()\n    if (token.close) {\n      let index = stack.length\n      let didRewind = false\n      while (--index > -1) {\n        if (stack[index].tagName === tagName) {\n          stack.splice(index)\n          didRewind = true\n          break\n        }\n      }\n      while (cursor < len) {\n        const endToken = tokens[cursor]\n        if (endToken.type !== 'tag-end') break\n        cursor++\n      }\n      if (didRewind) {\n        break\n      } else {\n        continue\n      }\n    }\n\n    const isClosingTag = Object(_compat__WEBPACK_IMPORTED_MODULE_0__[\"arrayIncludes\"])(options.closingTags, tagName)\n    let shouldRewindToAutoClose = isClosingTag\n    if (shouldRewindToAutoClose) {\n      const { closingTagAncestorBreakers: terminals } = options\n      shouldRewindToAutoClose = !hasTerminalParent(tagName, stack, terminals)\n    }\n\n    if (shouldRewindToAutoClose) {\n     \n     \n      let currentIndex = stack.length - 1\n      while (currentIndex > 0) {\n        if (tagName === stack[currentIndex].tagName) {\n          stack = stack.slice(0, currentIndex)\n          const previousIndex = currentIndex - 1\n          nodes = stack[previousIndex].children\n          break\n        }\n        currentIndex = currentIndex - 1\n      }\n    }\n\n    let attributes = []\n    let attrToken\n    while (cursor < len) {\n      attrToken = tokens[cursor]\n      if (attrToken.type === 'tag-end') break\n      attributes.push(attrToken.content)\n      cursor++\n    }\n\n    cursor++\n    const children = []\n\n    attributes = Array.isArray(attributes) && attributes.length\n      ? attributes.reduce((attrs, attr) => {\n          const parts = Object(_helpers__WEBPACK_IMPORTED_MODULE_1__[\"splitKeyValue\"])(attr, '=') \n          attrs[parts[0]] = parts[1] && Object(_helpers__WEBPACK_IMPORTED_MODULE_1__[\"unquote\"])(parts[1]) || ''\n          return attrs\n        }, {})\n      : {}\n\n    nodes.push({\n      0: tagToken.content,\n      1: attributes,\n      2: children\n    })\n\n    const hasChildren = !(attrToken.close || Object(_compat__WEBPACK_IMPORTED_MODULE_0__[\"arrayIncludes\"])(options.voidTags, tagName))\n    if (hasChildren) {\n      stack.push({tagName, children})\n      const innerState = {tokens, options, cursor, stack}\n      parse(innerState)\n      cursor = innerState.cursor\n    }\n  }\n  state.cursor = cursor\n}\n\n//# sourceURL=webpack://symplasm/./src/scripts/parser.js?");

/***/ }),

/***/ "./src/scripts/prop_map.js":
/*!*********************************!*\
  !*** ./src/scripts/prop_map.js ***!
  \*********************************/
/*! exports provided: propMap, revPropMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"propMap\", function() { return propMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"revPropMap\", function() { return revPropMap; });\nconst propMap = {\n \n  accept: 'accept',\n  acceptcharset: 'acceptCharset',\n  'accept-charset': 'acceptCharset',\n  accesskey: 'accessKey',\n  action: 'action',\n  allowfullscreen: 'allowFullScreen',\n  alt: 'alt',\n  as: 'as',\n  async: 'async',\n  autocapitalize: 'autoCapitalize',\n  autocomplete: 'autoComplete',\n  autocorrect: 'autoCorrect',\n  autofocus: 'autoFocus',\n  autoplay: 'autoPlay',\n  autosave: 'autoSave',\n  capture: 'capture',\n  cellpadding: 'cellPadding',\n  cellspacing: 'cellSpacing',\n  challenge: 'challenge',\n  charset: 'charSet',\n  checked: 'checked',\n  children: 'children',\n  cite: 'cite',\n  class: 'className',\n  classid: 'classID',\n  classname: 'className',\n  cols: 'cols',\n  colspan: 'colSpan',\n  content: 'content',\n  contenteditable: 'contentEditable',\n  contextmenu: 'contextMenu',\n  controls: 'controls',\n  controlslist: 'controlsList',\n  coords: 'coords',\n  crossorigin: 'crossOrigin',\n  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',\n  data: 'data',\n  datetime: 'dateTime',\n  default: 'default',\n  defaultchecked: 'defaultChecked',\n  defaultvalue: 'defaultValue',\n  defer: 'defer',\n  dir: 'dir',\n  disabled: 'disabled',\n  download: 'download',\n  draggable: 'draggable',\n  enctype: 'encType',\n  for: 'htmlFor',\n  form: 'form',\n  formmethod: 'formMethod',\n  formaction: 'formAction',\n  formenctype: 'formEncType',\n  formnovalidate: 'formNoValidate',\n  formtarget: 'formTarget',\n  frameborder: 'frameBorder',\n  headers: 'headers',\n  height: 'height',\n  hidden: 'hidden',\n  high: 'high',\n  href: 'href',\n  hreflang: 'hrefLang',\n  htmlfor: 'htmlFor',\n  httpequiv: 'httpEquiv',\n  'http-equiv': 'httpEquiv',\n  icon: 'icon',\n  id: 'id',\n  innerhtml: 'innerHTML',\n  inputmode: 'inputMode',\n  integrity: 'integrity',\n  is: 'is',\n  itemid: 'itemID',\n  itemprop: 'itemProp',\n  itemref: 'itemRef',\n  itemscope: 'itemScope',\n  itemtype: 'itemType',\n  keyparams: 'keyParams',\n  keytype: 'keyType',\n  kind: 'kind',\n  label: 'label',\n  lang: 'lang',\n  list: 'list',\n  loop: 'loop',\n  low: 'low',\n  manifest: 'manifest',\n  marginwidth: 'marginWidth',\n  marginheight: 'marginHeight',\n  max: 'max',\n  maxlength: 'maxLength',\n  media: 'media',\n  mediagroup: 'mediaGroup',\n  method: 'method',\n  min: 'min',\n  minlength: 'minLength',\n  multiple: 'multiple',\n  muted: 'muted',\n  name: 'name',\n  nomodule: 'noModule',\n  nonce: 'nonce',\n  novalidate: 'noValidate',\n  open: 'open',\n  optimum: 'optimum',\n  pattern: 'pattern',\n  placeholder: 'placeholder',\n  playsinline: 'playsInline',\n  poster: 'poster',\n  preload: 'preload',\n  profile: 'profile',\n  radiogroup: 'radioGroup',\n  readonly: 'readOnly',\n  referrerpolicy: 'referrerPolicy',\n  rel: 'rel',\n  required: 'required',\n  reversed: 'reversed',\n  role: 'role',\n  rows: 'rows',\n  rowspan: 'rowSpan',\n  sandbox: 'sandbox',\n  scope: 'scope',\n  scoped: 'scoped',\n  scrolling: 'scrolling',\n  seamless: 'seamless',\n  selected: 'selected',\n  shape: 'shape',\n  size: 'size',\n  sizes: 'sizes',\n  span: 'span',\n  spellcheck: 'spellCheck',\n  src: 'src',\n  srcdoc: 'srcDoc',\n  srclang: 'srcLang',\n  srcset: 'srcSet',\n  start: 'start',\n  step: 'step',\n  style: 'style',\n  summary: 'summary',\n  tabindex: 'tabIndex',\n  target: 'target',\n  title: 'title',\n  type: 'type',\n  usemap: 'useMap',\n  value: 'value',\n  width: 'width',\n  wmode: 'wmode',\n  wrap: 'wrap',\n\n \n  about: 'about',\n  accentheight: 'accentHeight',\n  'accent-height': 'accentHeight',\n  accumulate: 'accumulate',\n  additive: 'additive',\n  alignmentbaseline: 'alignmentBaseline',\n  'alignment-baseline': 'alignmentBaseline',\n  allowreorder: 'allowReorder',\n  alphabetic: 'alphabetic',\n  amplitude: 'amplitude',\n  arabicform: 'arabicForm',\n  'arabic-form': 'arabicForm',\n  ascent: 'ascent',\n  attributename: 'attributeName',\n  attributetype: 'attributeType',\n  autoreverse: 'autoReverse',\n  azimuth: 'azimuth',\n  basefrequency: 'baseFrequency',\n  baselineshift: 'baselineShift',\n  'baseline-shift': 'baselineShift',\n  baseprofile: 'baseProfile',\n  bbox: 'bbox',\n  begin: 'begin',\n  bias: 'bias',\n  by: 'by',\n  calcmode: 'calcMode',\n  capheight: 'capHeight',\n  'cap-height': 'capHeight',\n  clip: 'clip',\n  clippath: 'clipPath',\n  'clip-path': 'clipPath',\n  clippathunits: 'clipPathUnits',\n  cliprule: 'clipRule',\n  'clip-rule': 'clipRule',\n  color: 'color',\n  colorinterpolation: 'colorInterpolation',\n  'color-interpolation': 'colorInterpolation',\n  colorinterpolationfilters: 'colorInterpolationFilters',\n  'color-interpolation-filters': 'colorInterpolationFilters',\n  colorprofile: 'colorProfile',\n  'color-profile': 'colorProfile',\n  colorrendering: 'colorRendering',\n  'color-rendering': 'colorRendering',\n  contentscripttype: 'contentScriptType',\n  contentstyletype: 'contentStyleType',\n  cursor: 'cursor',\n  cx: 'cx',\n  cy: 'cy',\n  d: 'd',\n  datatype: 'datatype',\n  decelerate: 'decelerate',\n  descent: 'descent',\n  diffuseconstant: 'diffuseConstant',\n  direction: 'direction',\n  display: 'display',\n  divisor: 'divisor',\n  dominantbaseline: 'dominantBaseline',\n  'dominant-baseline': 'dominantBaseline',\n  dur: 'dur',\n  dx: 'dx',\n  dy: 'dy',\n  edgemode: 'edgeMode',\n  elevation: 'elevation',\n  enablebackground: 'enableBackground',\n  'enable-background': 'enableBackground',\n  end: 'end',\n  exponent: 'exponent',\n  externalresourcesrequired: 'externalResourcesRequired',\n  fill: 'fill',\n  fillopacity: 'fillOpacity',\n  'fill-opacity': 'fillOpacity',\n  fillrule: 'fillRule',\n  'fill-rule': 'fillRule',\n  filter: 'filter',\n  filterres: 'filterRes',\n  filterunits: 'filterUnits',\n  floodopacity: 'floodOpacity',\n  'flood-opacity': 'floodOpacity',\n  floodcolor: 'floodColor',\n  'flood-color': 'floodColor',\n  focusable: 'focusable',\n  fontfamily: 'fontFamily',\n  'font-family': 'fontFamily',\n  fontsize: 'fontSize',\n  'font-size': 'fontSize',\n  fontsizeadjust: 'fontSizeAdjust',\n  'font-size-adjust': 'fontSizeAdjust',\n  fontstretch: 'fontStretch',\n  'font-stretch': 'fontStretch',\n  fontstyle: 'fontStyle',\n  'font-style': 'fontStyle',\n  fontvariant: 'fontVariant',\n  'font-variant': 'fontVariant',\n  fontweight: 'fontWeight',\n  'font-weight': 'fontWeight',\n  format: 'format',\n  from: 'from',\n  fx: 'fx',\n  fy: 'fy',\n  g1: 'g1',\n  g2: 'g2',\n  glyphname: 'glyphName',\n  'glyph-name': 'glyphName',\n  glyphorientationhorizontal: 'glyphOrientationHorizontal',\n  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',\n  glyphorientationvertical: 'glyphOrientationVertical',\n  'glyph-orientation-vertical': 'glyphOrientationVertical',\n  glyphref: 'glyphRef',\n  gradienttransform: 'gradientTransform',\n  gradientunits: 'gradientUnits',\n  hanging: 'hanging',\n  horizadvx: 'horizAdvX',\n  'horiz-adv-x': 'horizAdvX',\n  horizoriginx: 'horizOriginX',\n  'horiz-origin-x': 'horizOriginX',\n  ideographic: 'ideographic',\n  imagerendering: 'imageRendering',\n  'image-rendering': 'imageRendering',\n  in2: 'in2',\n  in: 'in',\n  inlist: 'inlist',\n  intercept: 'intercept',\n  k1: 'k1',\n  k2: 'k2',\n  k3: 'k3',\n  k4: 'k4',\n  k: 'k',\n  kernelmatrix: 'kernelMatrix',\n  kernelunitlength: 'kernelUnitLength',\n  kerning: 'kerning',\n  keypoints: 'keyPoints',\n  keysplines: 'keySplines',\n  keytimes: 'keyTimes',\n  lengthadjust: 'lengthAdjust',\n  letterspacing: 'letterSpacing',\n  'letter-spacing': 'letterSpacing',\n  lightingcolor: 'lightingColor',\n  'lighting-color': 'lightingColor',\n  limitingconeangle: 'limitingConeAngle',\n  local: 'local',\n  markerend: 'markerEnd',\n  'marker-end': 'markerEnd',\n  markerheight: 'markerHeight',\n  markermid: 'markerMid',\n  'marker-mid': 'markerMid',\n  markerstart: 'markerStart',\n  'marker-start': 'markerStart',\n  markerunits: 'markerUnits',\n  markerwidth: 'markerWidth',\n  mask: 'mask',\n  maskcontentunits: 'maskContentUnits',\n  maskunits: 'maskUnits',\n  mathematical: 'mathematical',\n  mode: 'mode',\n  numoctaves: 'numOctaves',\n  offset: 'offset',\n  opacity: 'opacity',\n  operator: 'operator',\n  order: 'order',\n  orient: 'orient',\n  orientation: 'orientation',\n  origin: 'origin',\n  overflow: 'overflow',\n  overlineposition: 'overlinePosition',\n  'overline-position': 'overlinePosition',\n  overlinethickness: 'overlineThickness',\n  'overline-thickness': 'overlineThickness',\n  paintorder: 'paintOrder',\n  'paint-order': 'paintOrder',\n  panose1: 'panose1',\n  'panose-1': 'panose1',\n  pathlength: 'pathLength',\n  patterncontentunits: 'patternContentUnits',\n  patterntransform: 'patternTransform',\n  patternunits: 'patternUnits',\n  pointerevents: 'pointerEvents',\n  'pointer-events': 'pointerEvents',\n  points: 'points',\n  pointsatx: 'pointsAtX',\n  pointsaty: 'pointsAtY',\n  pointsatz: 'pointsAtZ',\n  prefix: 'prefix',\n  preservealpha: 'preserveAlpha',\n  preserveaspectratio: 'preserveAspectRatio',\n  primitiveunits: 'primitiveUnits',\n  property: 'property',\n  r: 'r',\n  radius: 'radius',\n  refx: 'refX',\n  refy: 'refY',\n  renderingintent: 'renderingIntent',\n  'rendering-intent': 'renderingIntent',\n  repeatcount: 'repeatCount',\n  repeatdur: 'repeatDur',\n  requiredextensions: 'requiredExtensions',\n  requiredfeatures: 'requiredFeatures',\n  resource: 'resource',\n  restart: 'restart',\n  result: 'result',\n  results: 'results',\n  rotate: 'rotate',\n  rx: 'rx',\n  ry: 'ry',\n  scale: 'scale',\n  security: 'security',\n  seed: 'seed',\n  shaperendering: 'shapeRendering',\n  'shape-rendering': 'shapeRendering',\n  slope: 'slope',\n  spacing: 'spacing',\n  specularconstant: 'specularConstant',\n  specularexponent: 'specularExponent',\n  speed: 'speed',\n  spreadmethod: 'spreadMethod',\n  startoffset: 'startOffset',\n  stddeviation: 'stdDeviation',\n  stemh: 'stemh',\n  stemv: 'stemv',\n  stitchtiles: 'stitchTiles',\n  stopcolor: 'stopColor',\n  'stop-color': 'stopColor',\n  stopopacity: 'stopOpacity',\n  'stop-opacity': 'stopOpacity',\n  strikethroughposition: 'strikethroughPosition',\n  'strikethrough-position': 'strikethroughPosition',\n  strikethroughthickness: 'strikethroughThickness',\n  'strikethrough-thickness': 'strikethroughThickness',\n  string: 'string',\n  stroke: 'stroke',\n  strokedasharray: 'strokeDasharray',\n  'stroke-dasharray': 'strokeDasharray',\n  strokedashoffset: 'strokeDashoffset',\n  'stroke-dashoffset': 'strokeDashoffset',\n  strokelinecap: 'strokeLinecap',\n  'stroke-linecap': 'strokeLinecap',\n  strokelinejoin: 'strokeLinejoin',\n  'stroke-linejoin': 'strokeLinejoin',\n  strokemiterlimit: 'strokeMiterlimit',\n  'stroke-miterlimit': 'strokeMiterlimit',\n  strokewidth: 'strokeWidth',\n  'stroke-width': 'strokeWidth',\n  strokeopacity: 'strokeOpacity',\n  'stroke-opacity': 'strokeOpacity',\n  suppresscontenteditablewarning: 'suppressContentEditableWarning',\n  suppresshydrationwarning: 'suppressHydrationWarning',\n  surfacescale: 'surfaceScale',\n  systemlanguage: 'systemLanguage',\n  tablevalues: 'tableValues',\n  targetx: 'targetX',\n  targety: 'targetY',\n  textanchor: 'textAnchor',\n  'text-anchor': 'textAnchor',\n  textdecoration: 'textDecoration',\n  'text-decoration': 'textDecoration',\n  textlength: 'textLength',\n  textrendering: 'textRendering',\n  'text-rendering': 'textRendering',\n  to: 'to',\n  transform: 'transform',\n  typeof: 'typeof',\n  u1: 'u1',\n  u2: 'u2',\n  underlineposition: 'underlinePosition',\n  'underline-position': 'underlinePosition',\n  underlinethickness: 'underlineThickness',\n  'underline-thickness': 'underlineThickness',\n  unicode: 'unicode',\n  unicodebidi: 'unicodeBidi',\n  'unicode-bidi': 'unicodeBidi',\n  unicoderange: 'unicodeRange',\n  'unicode-range': 'unicodeRange',\n  unitsperem: 'unitsPerEm',\n  'units-per-em': 'unitsPerEm',\n  unselectable: 'unselectable',\n  valphabetic: 'vAlphabetic',\n  'v-alphabetic': 'vAlphabetic',\n  values: 'values',\n  vectoreffect: 'vectorEffect',\n  'vector-effect': 'vectorEffect',\n  version: 'version',\n  vertadvy: 'vertAdvY',\n  'vert-adv-y': 'vertAdvY',\n  vertoriginx: 'vertOriginX',\n  'vert-origin-x': 'vertOriginX',\n  vertoriginy: 'vertOriginY',\n  'vert-origin-y': 'vertOriginY',\n  vhanging: 'vHanging',\n  'v-hanging': 'vHanging',\n  videographic: 'vIdeographic',\n  'v-ideographic': 'vIdeographic',\n  viewbox: 'viewBox',\n  viewtarget: 'viewTarget',\n  visibility: 'visibility',\n  vmathematical: 'vMathematical',\n  'v-mathematical': 'vMathematical',\n  vocab: 'vocab',\n  widths: 'widths',\n  wordspacing: 'wordSpacing',\n  'word-spacing': 'wordSpacing',\n  writingmode: 'writingMode',\n  'writing-mode': 'writingMode',\n  x1: 'x1',\n  x2: 'x2',\n  x: 'x',\n  xchannelselector: 'xChannelSelector',\n  xheight: 'xHeight',\n  'x-height': 'xHeight',\n  xlinkactuate: 'xlinkActuate',\n  'xlink:actuate': 'xlinkActuate',\n  xlinkarcrole: 'xlinkArcrole',\n  'xlink:arcrole': 'xlinkArcrole',\n  xlinkhref: 'xlinkHref',\n  'xlink:href': 'xlinkHref',\n  xlinkrole: 'xlinkRole',\n  'xlink:role': 'xlinkRole',\n  xlinkshow: 'xlinkShow',\n  'xlink:show': 'xlinkShow',\n  xlinktitle: 'xlinkTitle',\n  'xlink:title': 'xlinkTitle',\n  xlinktype: 'xlinkType',\n  'xlink:type': 'xlinkType',\n  xmlbase: 'xmlBase',\n  'xml:base': 'xmlBase',\n  xmllang: 'xmlLang',\n  'xml:lang': 'xmlLang',\n  xmlns: 'xmlns',\n  'xml:space': 'xmlSpace',\n  xmlnsxlink: 'xmlnsXlink',\n  'xmlns:xlink': 'xmlnsXlink',\n  xmlspace: 'xmlSpace',\n  y1: 'y1',\n  y2: 'y2',\n  y: 'y',\n  ychannelselector: 'yChannelSelector',\n  z: 'z',\n  zoomandpan: 'zoomAndPan',\n};\n\nconst revPropMap = Object.entries(propMap)\n    .reduce((obj, [key, value]) => ({ ...obj, [value]: key }), {});\n\n\n\n\n//# sourceURL=webpack://symplasm/./src/scripts/prop_map.js?");

/***/ }),

/***/ "./src/scripts/stringify.js":
/*!**********************************!*\
  !*** ./src/scripts/stringify.js ***!
  \**********************************/
/*! exports provided: formatAttributes, toHTML, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"formatAttributes\", function() { return formatAttributes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toHTML\", function() { return toHTML; });\n/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compat */ \"./src/scripts/compat.js\");\n/* harmony import */ var _prop_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./prop_map */ \"./src/scripts/prop_map.js\");\n\n\n\nlet options = {\n  attrLowerCase: false,\n  styleAsCss: false\n}\n\nfunction formatAttributes (attributes, options) {\n  let attrString = Object.keys(attributes).reduce((attrs, currentKey) => {\n    let key = currentKey\n    if(options.hasOpts && options.attrLowerCase && _prop_map__WEBPACK_IMPORTED_MODULE_1__[\"revPropMap\"][currentKey]) key = _prop_map__WEBPACK_IMPORTED_MODULE_1__[\"revPropMap\"][currentKey]\n    \n    let value = attributes[currentKey]\n    if (!value) return `${attrs} ${key}`\n    else if(key === 'style' && typeof value === 'object'){\n      let styles = ''\n      Object.keys(value).map(_name => {\n        let name = _name\n        if(options.hasOpts && options.styleAsCss) name = _name.split(/(?=[A-Z])/).join('-').toLowerCase()\n        \n        styles += `${name}:${value[_name]};`\n      })\n      const quoteEscape = styles.indexOf('\\'') !== -1\n      const quote = quoteEscape ? '\"' : '\\''\n      return `${attrs} ${key}=${quote}${styles}${quote}`\n    }\n    if(typeof value === 'boolean') value = `${value}`\n    \n    if(typeof value === 'string'){\n      const quoteEscape = value.indexOf('\\'') !== -1\n      const quote = quoteEscape ? '\"' : '\\''\n      return `${attrs} ${key}=${quote}${value}${quote}`\n    }\n    return attrs\n  }, '')\n  \n  attrString = typeof attrString === 'string' && attrString.trim() || ''\n  return attrString.length\n    ? ' '+attrString\n    : ''\n}\n\nconst buildTag = (tagName, attributes, children, options) => {\n\n  return `<${tagName}${formatAttributes(attributes, options)}>${toHTML(children, options) || '' }</${tagName}>`\n}\n\nconst buildSelfCloseTag = (tagName, attributes, options) => {\n  let formatted = formatAttributes(attributes, options)\n  formatted = formatted.length\n    ? formatted + ' '\n    : formatted\n  return `<${tagName}${formatted}${'/'}>`\n}\n\n\nfunction toHTML (tree, _options) {\n\n  options = options.hasOpts\n    ? Object.assign(options, _options)\n    : _options\n  \n  if (typeof tree === 'string') return tree\n  return tree && tree.map(node => {\n    if (typeof node === 'string') return node\n    if (node.type === 'comment') return `<!--${node.content}-->`\n    const tagName = node[0]\n    const attributes = node[1]\n    const children = node[2]\n    \n   \n   \n   \n   \n    const tagCheck = !children && tagName.toLowerCase() || tagName\n    const isSelfClosing = Object(_compat__WEBPACK_IMPORTED_MODULE_0__[\"arrayIncludes\"])(options.voidTags, tagCheck)\n\n    return isSelfClosing\n      ? buildSelfCloseTag(tagName, attributes, options)\n      : buildTag(tagName, attributes, children, options)\n  }).join('')\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({toHTML});\n\n\n//# sourceURL=webpack://symplasm/./src/scripts/stringify.js?");

/***/ }),

/***/ "./src/scripts/tags.js":
/*!*****************************!*\
  !*** ./src/scripts/tags.js ***!
  \*****************************/
/*! exports provided: childlessTags, closingTags, closingTagAncestorBreakers, voidTags */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"childlessTags\", function() { return childlessTags; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"closingTags\", function() { return closingTags; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"closingTagAncestorBreakers\", function() { return closingTagAncestorBreakers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"voidTags\", function() { return voidTags; });\nconst childlessTags = ['style', 'script', 'template']\n\nconst closingTags = [\n  'html', 'head', 'body', 'p', 'dt', 'dd', 'li', 'option',\n  'thead', 'th', 'tbody', 'tr', 'td', 'tfoot', 'colgroup'\n]\n\nconst closingTagAncestorBreakers = {\n  li: ['ul', 'ol', 'menu'],\n  dt: ['dl'],\n  dd: ['dl'],\n  tbody: ['table'],\n  thead: ['table'],\n  tfoot: ['table'],\n  tr: ['table'],\n  td: ['table']\n}\n\nconst voidTags = [\n  '!doctype', 'area', 'base', 'br', 'col', 'command',\n  'embed', 'hr', 'img', 'input', 'keygen', 'link',\n  'meta', 'param', 'source', 'track', 'wbr'\n]\n\n\n//# sourceURL=webpack://symplasm/./src/scripts/tags.js?");

/***/ })

/******/ });